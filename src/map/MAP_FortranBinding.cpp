/**
 * ====================================================================================================
 *                              FortranBinding.cpp
 * ====================================================================================================
 *	     
 * Copyright Sept. 2012
 * 
 * Author: 
 * National Renewable Energy Laboratory, Golden, Colorado, USA
 *
 * This file is part of the Mooring Analysis Program (MAP).
 *
 * MAP is free software: you can redistribute it and/or modify it under the terms 
 * of the GNU General Public License as published by the Free Software Foundation, 
 * either version 3 of the License, or (at your option) any later version.
 *
 * MAP is distributed in the hope that it will be useful, but WITHOUT ANY 
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along 
 * with MAP. If not, see:
 * 
 * < http://www.gnu.org/licenses/>
 * ====================================================================================================
 */


#include "MAP_Types.h"
#include "MAP_FortranBinding.h"


// ==========   MAP Object Con/Destructor   ===============     <---------------------------------+
//                                                                                    //          |
// This creates instance of MAP objects in Fortran.                                   //          |
// Note: The interface for these methods (both the constructor and destructor)        //          |
//       is in MAP_C_Types.f90, which is auto-generated by the FAST registry.         //          |
                                                                                      //          |
extern "C" CALL MAP_InitInputType_class*                                              //          |
MAP_InitInput_Create( ){ return new MAP_InitInputType_class( ); };                    //          |
                                                                                      //          |
extern "C" CALL MAP_InitOutputType_class*                                             //          |
MAP_InitOutput_Create( ){ return new MAP_InitOutputType_class( ); };                  //          |
                                                                                      //          |
extern "C" CALL MAP_InputType_class*                                                  //          |
MAP_Input_Create( ){ return new MAP_InputType_class( ); };                            //          |
                                                                                      //          |
extern "C" CALL MAP_ParameterType_class*                                              //          |
MAP_Param_Create( ){ return new MAP_ParameterType_class( ); };                        //          |
                                                                                      //          |
extern "C" CALL MAP_ContinuousStateType_class*                                        //          |
MAP_ContState_Create( ){ return new MAP_ContinuousStateType_class( ); };              //          |
                                                                                      //          |
extern "C" CALL MAP_DiscreteStateType_class*                                          //          |
MAP_DiscState_Create( ){ return new MAP_DiscreteStateType_class( ); };                //          |
                                                                                      //          |
extern "C" CALL MAP_ConstraintStateType_class*                                        //          |
MAP_ConstrState_Create( ){ return new MAP_ConstraintStateType_class( ); };            //          |
                                                                                      //          |
extern "C" CALL MAP_OtherStateType_class*                                             //          |
MAP_OtherState_Create( ){ return new MAP_OtherStateType_class( ); };                  //          |
                                                                                      //          |
extern "C" CALL MAP_OutputType_class*                                                 //          |
MAP_Output_Create( ){ return new MAP_OutputType_class( ); };                          //          |
                                                                                      //          |
extern "C" CALL void                                                                  //          |
MAP_InitInput_Delete( MAP_InitInputType_class *This ){ delete This; }                 //          |
                                                                                      //          |
extern "C" CALL void                                                                  //          |
MAP_InitOutput_Delete( MAP_InitOutputType_class *This ){ delete This; }               //          |
                                                                                      //          |
extern "C" CALL void                                                                  //          |
MAP_Input_Delete( MAP_InputType_class *This ){ delete This; }                         //          |
                                                                                      //          |
extern "C" CALL void                                                                  //          |
MAP_Param_Delete( MAP_ParameterType_class *This ){ delete This; }                     //          |
                                                                                      //          |
extern "C" CALL void                                                                  //          |
MAP_ContState_Delete( MAP_ContinuousStateType_class *This ){ delete This; }           //          |
                                                                                      //          |
extern "C" CALL void                                                                  //          |
MAP_DiscState_Delete( MAP_DiscreteStateType_class *This ){ delete This; }             //          |
                                                                                      //          |
extern "C" CALL void                                                                  //          |
MAP_ConstrState_Delete( MAP_ConstraintStateType_class *This ){ delete This; }         //          |
                                                                                      //          |
extern "C" CALL void                                                                  //          |
MAP_OtherState_Delete( MAP_OtherStateType_class *This ){ delete This; }               //          |
                                                                                      //          |
extern "C"  CALL void                                                                 //          |
MAP_Output_Delete( MAP_OutputType_class *This ){ delete This; }                       //   -------+
//=================================================================================================



// ==========   MAPCALL_MSQS_Init Subroutine Bindings   ===============
//                                                            
// This is called by the FAST glue code 
extern "C" CALL void                                               
MAPCALL_MSQS_Init( MAP_InitInputType       *InitInp     ,     
                   MAP_InputType           *InputData   ,     
                   MAP_ParameterType       *ParamData   ,     
                   MAP_ContinuousStateType *ContData    ,     
                   MAP_DiscreteStateType   *DiscData    ,     
                   MAP_ConstraintStateType *ConstrData  ,     
                   MAP_OtherStateType      *OtherData   ,     
                   MAP_OutputType          *OutData     ,     
                   MAP_InitOutputType      *InitOutData ,     
                   int                     *stat        ,     
                   char                    *msg         )  
{
  MAP_ErrStat_class Error;
  MAP_Message_class Msg;
  void* Nothing = NULL;  
  
  MAP_InitInputType_class *inp = static_cast<MAP_InitInputType_class*>(InitInp->object);
  MAP_InputType_class *u = static_cast<MAP_InputType_class*>(InputData->object);
  MAP_ParameterType_class *p = static_cast<MAP_ParameterType_class*>(ParamData->object);
  MAP_ConstraintStateType_class *z = static_cast<MAP_ConstraintStateType_class*>(ConstrData->object);
  MAP_OtherStateType_class *o = static_cast<MAP_OtherStateType_class*>(OtherData->object);
  MAP_OutputType_class *y = static_cast<MAP_OutputType_class*>(OutData->object);
  MAP_InitOutputType_class *out = static_cast<MAP_InitOutputType_class*>(InitOutData->object);

    MSQS_Init( *inp    , 
             *u      , 
             *p      , 
             Nothing , 
             Nothing , 
             *z      , 
             *o      , 
             *y      , 
             Nothing , 
             *out    , 
             Error   , 
             Msg     );

  std::string buildDate = "";
  buildDate += BUILD_MONTH_CH0  ;
  buildDate += BUILD_MONTH_CH1;
  buildDate += BUILD_MONTH_CH2;
  buildDate += "-"            ;
  buildDate += BUILD_DAY_CH0  ;
  buildDate += BUILD_DAY_CH1  ;
  buildDate += "-"            ;  
  buildDate += BUILD_YEAR_CH0 ;
  buildDate += BUILD_YEAR_CH1 ;
  buildDate += BUILD_YEAR_CH2 ;
  buildDate += BUILD_YEAR_CH3 ;

  try {
    MAPSetInputArray      ( InputData , u      , OtherData, o );
    MAPSetParameterArray  ( ParamData , p      , OtherData, o );
    MAPSetConstraintArray ( ConstrData, z      , OtherData, o );
    MAPSetOtherArray      ( Nothing   , Nothing, OtherData, o );
    MAPSetOutputArray     ( OutData   , y      , OtherData, o );
    MAPPackOutput         ( OutData   , y      , OtherData, o );
    
    // get the program version and build date so that FAST can use this information for something. 
    strcpy( InitOutData->MAP_version, PROGVERSION );
    strcpy( InitOutData->MAP_date, buildDate.c_str() );
  } catch( MAP_ERROR_CODE code ) {
    //MAPSetUniversalErrorStat( code, Error, Msg );
  }

  *stat = Error.error_status();

  if( *stat != MAP_SAFE ) {
    std::string message = Msg.GetErrorMessage();
    strcpy( msg , message.c_str() );
  }
};


// ==========   MAPCALL_MSQS_CalcOutput Subroutine Bindings   ===============
//                                                            
// This is called by the FAST glue code 
extern "C" CALL void 
MAPCALL_MSQS_UpdateStates( float                   time        , 
                           int                     N           , 
                           MAP_InputType           *InputData  , 
                           MAP_ParameterType       *ParamData  ,                                     
                           MAP_ContinuousStateType *ContData   , 
                           MAP_DiscreteStateType   *DiscData   ,                         
                           MAP_ConstraintStateType *ConstrData , 
                           MAP_OtherStateType      *OtherData  , 
                           int                     *stat       , 
                           char                    *msg )
{
  MAP_ErrStat_class Error;
  MAP_Message_class Msg;
  void* Nothing = NULL;

  MAP_InputType_class *u = static_cast<MAP_InputType_class*>(InputData->object);
  MAP_ParameterType_class *p = static_cast<MAP_ParameterType_class*>(ParamData->object);
  MAP_ConstraintStateType_class *z = static_cast<MAP_ConstraintStateType_class*>(ConstrData->object);
  MAP_OtherStateType_class *o = static_cast<MAP_OtherStateType_class*>(OtherData->object);

  try {
    MAPUnpackInput     ( InputData , u, OtherData );
    MAPUnpackParameter ( ParamData , p, OtherData );
    MAPUnpackConstraint( ConstrData, z, OtherData );
    MAPUnpackOther     ( OtherData , o            );
  } catch( MAP_ERROR_CODE &code ) { 
    /*MAPSetUniversalErrorStat( code, Error, Msg );*/ 
  }

  MSQS_UpdateStates( time    ,                                                                    
                     N       ,                                                                    
                     *u      ,
                     *p      ,
                     Nothing ,                                                                    
                     Nothing ,                                                                    
                     *z      ,
                     *o      ,
                     Error   ,                                                                    
                     Msg     );

  *stat = Error.error_status();
  
  if( *stat != MAP_SAFE ) {
    std::string message = Msg.GetErrorMessage();
    strcpy( msg , message.c_str() );
  }
};


// ==========   MAPCALL_MSQS_CalcOutput Subroutine Bindings   ===============
//                                                            
// This is called by the FAST glue code 
extern "C" CALL void
MAPCALL_MSQS_CalcOutput( float                   time        , 
                         MAP_InputType           *InputData  , 
                         MAP_ParameterType       *ParamData  ,  
                         MAP_ContinuousStateType *ContData   , 
                         MAP_DiscreteStateType   *DiscData   ,   
                         MAP_ConstraintStateType *ConstrData , 
                         MAP_OtherStateType      *OtherData  ,   
                         MAP_OutputType          *OutData    , 
                         int                     *stat       , 
                         char                    *msg )                    
{                                                                                         
  MAP_ErrStat_class Error;                                                                      
  MAP_Message_class Msg;                                                                        
  void* Nothing = NULL;                                                                   

  MAP_InputType_class *u = static_cast<MAP_InputType_class*>(InputData->object);
  MAP_ParameterType_class *p = static_cast<MAP_ParameterType_class*>(ParamData->object);
  MAP_ConstraintStateType_class *z = static_cast<MAP_ConstraintStateType_class*>(ConstrData->object);
  MAP_OtherStateType_class *o = static_cast<MAP_OtherStateType_class*>(OtherData->object);
  MAP_OutputType_class *y = static_cast<MAP_OutputType_class*>(OutData->object);
                                                                                          
  MSQS_CalcOutput( time    ,                                                
                   *u      ,
                   *p      ,
                   Nothing ,                                                
                   Nothing ,                                                
                   *z      ,
                   *o      ,
                   *y      ,
                   Error   ,                                                
                   Msg     );                                                                 

  try {
    MAPPackInput     ( InputData , u, OtherData );
    MAPPackOutput    ( OutData   , y, OtherData , o );
    MAPPackParameter ( ParamData , p, OtherData );
    MAPPackConstraint( ConstrData, z, OtherData ); 
  } catch( MAP_ERROR_CODE code ) { 
    /*MAPSetUniversalErrorStat( code, Error, Msg );*/ 
  }
  
  *stat = Error.error_status();                                                           
                                                                                          
  if( *stat != MAP_SAFE ) {                                                               
    std::string message = Msg.GetErrorMessage();                                            
    strcpy( msg , message.c_str() );                                                      
  }
};


// ==========   MAPCALL_MSQS_End Subroutine Bindings   ===============
//                                                            
// This is called by the FAST glue code to destroy data structures
// and deallocate memory. Such is the case for all pointers in the
// MAP_XZYTypes structures in MAP_Types.c files. 
extern "C" CALL void
MAPCALL_MSQS_End( MAP_InputType           *InputData  , 
                  MAP_ParameterType       *ParamData  , 
                  MAP_ContinuousStateType *ContData   , 
                  MAP_DiscreteStateType   *DiscData   , 
                  MAP_ConstraintStateType *ConstrData , 
                  MAP_OtherStateType      *OtherData  , 
                  MAP_OutputType          *OutData    , 
                  int                     *stat       , 
                  char                    *msg )         
{
  MAP_ErrStat_class Error;
  MAP_Message_class Msg;
  void* Nothing = NULL;

  MAP_InputType_class *u = static_cast<MAP_InputType_class*>(InputData->object);
  MAP_ParameterType_class *p = static_cast<MAP_ParameterType_class*>(ParamData->object);
  MAP_ConstraintStateType_class *z = static_cast<MAP_ConstraintStateType_class*>(ConstrData->object);
  MAP_OtherStateType_class *o = static_cast<MAP_OtherStateType_class*>(OtherData->object);
  MAP_OutputType_class *y = static_cast<MAP_OutputType_class*>(OutData->object);

  MSQS_End( *u      ,                                                                            
            *p      ,                                                                            
            Nothing ,                                                                            
            Nothing ,                                                                            
            *z      ,                                                                            
            *o      ,                                                                            
            *y      ,                                                                            
            Error   ,                                                                            
            Msg     );
  
  MAPDeleteInputArray     ( InputData  );
  MAPDeleteConstraintArray( ConstrData );
  MAPDeleteOutputArray    ( OutData    );
  MAPDeleteParameterArray ( ParamData  );
  MAPDeleteOtherArray     ( OtherData  );
  
  *stat = Error.error_status();

  if( *stat != MAP_SAFE ) {  
    std::string message = Msg.GetErrorMessage();
    strcpy( msg , message.c_str() ); 
  }
};


// ==========   MAPSetInputArray   =======================================
//                                                            
// Initializes the pointers in MAP_InputType (defines in MAP_Types.h)
// to create an array of values. 
void 
MAPSetInputArray( MAP_InputType            *input , 
                  MAP_InputType_class      *u     ,
                  MAP_OtherStateType       *other ,
                  MAP_OtherStateType_class *o )
{              
  std::vector<double> valArray;                                                         
  std::vector<int> idxArray;                                                            
                                                                                        
  // set the length and population of the X Input variable                              
  MAPSetArrayIndex( "X" , input->X_Len , u , idxArray , valArray );      
  input->X = new double[ input->X_Len ];                                           
  for( int i=0 ; i<input->X_Len ; i++ ) input->X[i] = valArray[i];
                                                                                        
  // set the length and population of the T Input variable                              
  MAPSetArrayIndex( "Y" , input->Y_Len , u , idxArray , valArray ) ;      
  input->Y = new double[ input->Y_Len ];                                           
  for( int i=0 ; i<input->Y_Len ; i++ ) input->Y[i] = valArray[i];                 
                                                                                        
  // set the length and population of the Z Input variable                              
  MAPSetArrayIndex( "Z" , input->Z_Len , u , idxArray , valArray ) ;      
  input->Z = new double[ input->Z_Len ];                                           
  for( int i=0 ; i<input->Z_Len ; i++ ) input->Z[i] = valArray[i];                 
                                                                                        
  // finally, set the indexing suite                                                    
  other->u_index_Len = idxArray.size();                                              
  other->u_index = new int[ other->u_index_Len ];                                
  for( int i=0 ; i<other->u_index_Len ; i++ ) other->u_index[i] = idxArray[i];   
};


void 
MAPSetOtherArray( void*                    NULL_A ,
                  void*                    NULL_B ,
                  MAP_OtherStateType       *other ,
                  MAP_OtherStateType_class *o     )   
{                          
  std::vector<double> valArray;                                                
  std::vector<int> idxArray;                                                   
  std::vector<bool> valArrayBool;

  // set the _Length and population of the X constraint variable                
  MAPSetArrayIndex("FX", other->FX_Len , o , idxArray , valArray ) ;   
  other->FX = new double[ other->FX_Len ];                                      
  for( int i=0 ; i<other->FX_Len ; i++ ) other->FX[i] = valArray[i];
                                                                               
  // set the _Length and population of the X constraint variable                
  MAPSetArrayIndex("FY", other->FY_Len , o , idxArray , valArray ) ;   
  other->FY = new double[ other->FY_Len ];                                      
  for( int i=0 ; i<other->FY_Len ; i++ ) other->FY[i] = valArray[i];            
                                                                               
  // set the _Length and population of the X constraint variable                
  MAPSetArrayIndex("FZ", other->FZ_Len , o , idxArray , valArray ) ;   
  other->FZ = new double[ other->FZ_Len ];                                      
  for( int i=0 ; i<other->FZ_Len ; i++ ) other->FZ[i] = valArray[i];            

  // finally, set the indexing suite                                           
  other->o_index_Len = idxArray.size();                                           
  other->o_index = new int[ other->o_index_Len ];                                   
  for( int i=0 ; i<other->o_index_Len ; i++ ) other->o_index[i] = idxArray[i];      
};


void 
MAPSetOutputArray( MAP_OutputType           *output , 
                   MAP_OutputType_class     *y     ,
                   MAP_OtherStateType       *other ,
                   MAP_OtherStateType_class *o )  
{            
  std::vector<double> valArray;                                                          
  std::vector<int> idxArray;                                                             
                                                                                         
  // set the length and population of the FX Output variable                             
  MAPSetArrayIndex( "FX" , output->FX_Len , y , idxArray , valArray ) ;  
  output->FX = new double[ output->FX_Len ];                                        
  for( int i=0 ; i<output->FX_Len ; i++ ) output->FX[i] = valArray[i];              
                                                                                         
  // set the length and population of the FY Output variable                             
  MAPSetArrayIndex( "FY" , output->FY_Len , y , idxArray , valArray ) ;  
  output->FY = new double[ output->FY_Len ];                                        
  for( int i=0 ; i<output->FY_Len ; i++ ) output->FY[i] = valArray[i];              
                                                                                         
  // set the length and population of the FZ Output variable                             
  MAPSetArrayIndex( "FZ" , output->FZ_Len , y , idxArray , valArray ) ;  
  output->FZ = new double[ output->FZ_Len ];                                        
  for( int i=0 ; i<output->FZ_Len ; i++ ) output->FZ[i] = valArray[i];              
                                                                                         
  // finally, set the indexing suite                                                     
  other->y_index_Len = idxArray.size();                                              
  other->y_index = new int[ other->y_index_Len ];                               
  for( int i=0 ; i<other->y_index_Len ; i++ ) other->y_index[i] = idxArray[i];  

  // set the length and population of the FZ Output variable              
  output->writeOutput_Len = o->MAPCALL_GetNumberOfOutputs();
  output->writeOutput = new float[ output->writeOutput_Len ];                                       
  for( int i=0 ; i<output->writeOutput_Len ; i++ ) output->writeOutput[i] = -999.9;              
};


void 
MAPSetParameterArray( MAP_ParameterType        *param , 
                      MAP_ParameterType_class  *p     ,
                      MAP_OtherStateType       *other ,
                      MAP_OtherStateType_class *o )  
{
  std::vector<double> valArray;                                                                             
  std::vector<int> idxArray;                                                                                

  //set the length and population of the Diam parameter variable                                           
  MAPSetArrayIndex("Diam", param->Diam_Len , p , idxArray , valArray );                     
  param->Diam = new double[ param->Diam_Len ];
  for( int i=0 ; i<param->Diam_Len ; i++ ) param->Diam[i] = valArray[i];                                 
                                                                                                            
  // set the length and population of the MassDenInAir parameter variable                                   
  MAPSetArrayIndex("MassDenInAir", param->MassDenInAir_Len , p , idxArray , valArray ) ;    
  param->MassDenInAir = new double[ param->MassDenInAir_Len ];                                           
  for( int i=0 ; i<param->MassDenInAir_Len ; i++ ) param->MassDenInAir[i] = valArray[i];                 
                                                                                                            
  // set the length and population of the EA parameter variable                                             
  MAPSetArrayIndex("EA", param->EA_Len , p , idxArray , valArray ) ;                        
  param->EA = new double[ param->EA_Len ];                                                               
  for( int i=0 ; i<param->EA_Len ; i++ ) param->EA[i] = valArray[i];                                     
                                                                                                            
  // set the length and population of the CB parameter variable                                             
  MAPSetArrayIndex( "CB" , param->CB_Len , p , idxArray , valArray ) ;                      
  param->CB = new double[ param->CB_Len ];                                                               
  for( int i=0 ; i<param->CB_Len ; i++ ) param->CB[i] = valArray[i];                                     
                                                                                                            
  // set the length and population of the Lu parameter variable                                             
  MAPSetArrayIndex( "Lu" , param->Lu_Len , p , idxArray , valArray ) ;                      
  param->Lu = new double[ param->Lu_Len ];                                                               
  for( int i=0 ; i<param->Lu_Len ; i++ ) param->Lu[i] = valArray[i];                                     

  // set the length and population of the X parameter variable                                             
  MAPSetArrayIndex( "X" , param->X_Len , p , idxArray , valArray ) ;                      
  param->X = new double[ param->X_Len ];                                                               
  for( int i=0 ; i<param->X_Len ; i++ ) param->X[i] = valArray[i];                                     

  // set the length and population of the Y parameter variable                                             
  MAPSetArrayIndex( "Y" , param->Y_Len , p , idxArray , valArray ) ;                      
  param->Y = new double[ param->Y_Len ];                                                               
  for( int i=0 ; i<param->Y_Len ; i++ ) param->Y[i] = valArray[i];                                     

  // set the length and population of the Z parameter variable                                             
  MAPSetArrayIndex( "Z" , param->Z_Len , p , idxArray , valArray ) ;                      
  param->Z = new double[ param->Z_Len ];                                                               
  for( int i=0 ; i<param->Z_Len ; i++ ) param->Z[i] = valArray[i];                                     

  // set the length and population of the FX parameter variable                                             
  MAPSetArrayIndex( "FX" , param->FX_Len , p , idxArray , valArray ) ;                      
  param->FX = new double[ param->FX_Len ];                                                               
  for( int i=0 ; i<param->FX_Len ; i++ ) param->FX[i] = valArray[i];                                     

  // set the length and population of the FY parameter variable                                             
  MAPSetArrayIndex( "FY" , param->FY_Len , p , idxArray , valArray ) ;                      
  param->FY = new double[ param->FY_Len ];                                                               
  for( int i=0 ; i<param->FY_Len ; i++ ) param->FY[i] = valArray[i];                                     

  // set the length and population of the FZ parameter variable                                             
  MAPSetArrayIndex( "FZ" , param->FZ_Len , p , idxArray , valArray ) ;                      
  param->FZ = new double[ param->FZ_Len ];                                                               
  for( int i=0 ; i<param->FZ_Len ; i++ ) param->FZ[i] = valArray[i];                                     

  // set the length and population of the M parameter variable                                             
  MAPSetArrayIndex( "M" , param->M_Len , p , idxArray , valArray ) ;                      
  param->M = new double[ param->M_Len ];                                                               
  for( int i=0 ; i<param->M_Len ; i++ ) param->M[i] = valArray[i];                                     

  // set the length and population of the B parameter variable                                             
  MAPSetArrayIndex( "B" , param->B_Len , p , idxArray , valArray ) ;                      
  param->B = new double[ param->B_Len ];                                                               
  for( int i=0 ; i<param->B_Len ; i++ ) param->B[i] = valArray[i];

  // finally, set the indexing suite                                                                        
  other->p_index_Len = idxArray.size();                                                              
  other->p_index = new int[ other->p_index_Len ];                                            
  for( int i=0 ; i<other->p_index_Len ; i++ ) other->p_index[i] = idxArray[i]; 
};


void 
MAPSetConstraintArray( MAP_ConstraintStateType       *constr , 
                       MAP_ConstraintStateType_class *z     ,
                       MAP_OtherStateType            *other ,
                       MAP_OtherStateType_class      *o )  
{
  std::vector<double> valArray;                                                                 
  std::vector<int> idxArray;                                                                    
                                                                                                
  // set the length and population of the X constraint variable                                 
  MAPSetArrayIndex( "X", constr->X_Len , z , idxArray , valArray ) ; 
  constr->X = new double[ constr->X_Len ];                                         
  for( int i=0 ; i<constr->X_Len ; i++ ) constr->X[i] = valArray[i];               
                                       
  // set the length and population of the Y constraint variable                                 
  MAPSetArrayIndex( "Y", constr->Y_Len , z , idxArray , valArray ) ; 
  constr->Y = new double[ constr->Y_Len ];                                         
  for( int i=0 ; i<constr->Y_Len ; i++ ) constr->Y[i] = valArray[i];               
                                                                                                
  // set the length and population of the Z constraint variable                                 
  MAPSetArrayIndex( "Z", constr->Z_Len , z , idxArray , valArray ) ; 
  constr->Z = new double[ constr->Z_Len ];                                         
  for( int i=0 ; i<constr->Z_Len ; i++ ) constr->Z[i] = valArray[i];               
                                                                                                
  // set the length and population of the H constraint variable                                 
  MAPSetArrayIndex( "H", constr->H_Len , z , idxArray , valArray ) ; 
  constr->H = new double[ constr->H_Len ];                                         
  for( int i=0 ; i<constr->H_Len ; i++ ) constr->H[i] = valArray[i];               
                                                                                                
  // set the length and population of the V constraint variable                                 
  MAPSetArrayIndex( "V", constr->V_Len , z , idxArray , valArray ) ; 
  constr->V = new double[ constr->V_Len ];                                         
  for( int i=0 ; i<constr->V_Len ; i++ ) constr->V[i] = valArray[i];               
                                                                                                
  // finally, set the indexing suite                                                            
  other->z_index_Len = idxArray.size();                                                 
  other->z_index = new int[ other->z_index_Len ];                              
  for( int i=0 ; i<other->z_index_Len ; i++ ) other->z_index[i] = idxArray[i]; 
};


// Sets the gravity constant as specified by FAST
extern "C" CALL void 
MAPCALL_SetGravity( MAP_InitInputType *InitInp )                                    
{ 
  MAP_InitInputType_class *inp;
  inp = static_cast<MAP_InitInputType_class*>(InitInp->object);
  inp->SetGravity( InitInp->gravity ); 
};                                 


// Sets the water depth constant as specified by FAST
extern "C" CALL void 
MAPCALL_SetDepth( MAP_InitInputType *InitInp )                                    
{ 
  MAP_InitInputType_class *inp;
  inp = static_cast<MAP_InitInputType_class*>(InitInp->object);
  inp->SetDepth( InitInp->depth ); 
};
                                                                                
                         
// Sets the sea density constant as specified by FAST                                                       
extern "C" CALL void 
MAPCALL_SetDensity( MAP_InitInputType *InitInp )                                    
{ 
  MAP_InitInputType_class *inp;
  inp = static_cast<MAP_InitInputType_class*>(InitInp->object);
  inp->SetSeaDensity( InitInp->sea_density ); 
};


// Let MAP know that FAST is calling it. Setting
extern "C" CALL void 
MAPCALL_SetFastCouplingFlag( MAP_InitInputType *InitInp )                                    
{ 
  MAP_InitInputType_class *inp;
  inp = static_cast<MAP_InitInputType_class*>(InitInp->object);
  inp->SetCoupledToFastFlag( InitInp->coupled_to_FAST ); 
};                                 


// Sets the cable library data word string
extern "C" CALL void 
MAPCALL_SetCableLibraryData( MAP_InitInputType *InitInp )
{                                                                               
  std::stringstream S;                                                          
  MAP_InitInputType_class *inp;
  inp = static_cast<MAP_InitInputType_class*>(InitInp->object);
  
  S << InitInp->cable_library_data;                                            
  S << "\n";
  inp->SetCableLibraryData( S.str() );                               
//  inp->
};                                                                              

                                          
// Sets the node data word string                                      
extern "C" CALL void 
MAPCALL_SetNodeData( MAP_InitInputType *InitInp )
{                                                                               
  std::stringstream S;                                                          
  MAP_InitInputType_class *inp;
  inp = static_cast<MAP_InitInputType_class*>(InitInp->object);
  
  S << InitInp->node_data;                                                     
  S << "\n";
  inp->SetNodeData( S.str() );                                       
};                                                                              
                                                                                

// Sets the element data word string
extern "C" CALL void 
MAPCALL_SetElementData( MAP_InitInputType *InitInp )
{
  std::stringstream S;                                                          
  MAP_InitInputType_class *inp;
  inp = static_cast<MAP_InitInputType_class*>(InitInp->object);

  S << InitInp->element_data;
  S << "\n";
  inp->SetElementData( S.str() );                                    
};                                                                              
                                                                                

// Sets the solver options data word string
extern "C" CALL void 
MAPCALL_SetSolverOptions( MAP_InitInputType *InitInp )
{
  std::stringstream S;                                                          
  MAP_InitInputType_class *inp;
  inp = static_cast<MAP_InitInputType_class*>(InitInp->object);

  S << InitInp->solver_data;                                                
  S << "\n";
  inp->SetSolverOptions( S.str() );                                  
};                                                                                        


// Get the number of items/variables being written to the FAST output file
extern "C" CALL int
MAPCALL_NumberOfHeaders( MAP_OtherStateType *O )
{ 
  MAP_OtherStateType_class *other = static_cast<MAP_OtherStateType_class*>(O->object);
  return other->MAPCALL_GetNumberOfOutputs( );
};


// 
extern "C" CALL void
MAPCALL_ModifyHeaderString( int  *N, char **strArr , MAP_OtherStateType *O ) 
{ 
  MAP_OtherStateType_class *other = static_cast<MAP_OtherStateType_class*>(O->object);
  other->MAPCALL_GetOutputHeader( strArr );
};


// 
extern "C" CALL void
MAPCALL_ModifyHeaderUnitString( int  *N, char **strArr , MAP_OtherStateType *O ) 
{ 
  MAP_OtherStateType_class *other = static_cast<MAP_OtherStateType_class*>(O->object);
  other->MAPCALL_GetOutputHeaderUnits( strArr );
};


// ==========   UnpackConstraint   =======================================
//                                                            
// These functions are called at each time step to change/set values 
// inside the MAP classes (not exposed to Fortran). In the spirit of 
// the SetVaraibleArrayIndex(..) functions about, this step actually 
// sets values. 
//
// Variables __MUST__ be unpacked in this order:
//   
// X, Y, Z, H, V
void 
MAPUnpackConstraint( MAP_ConstraintStateType       *constrData ,
                     MAP_ConstraintStateType_class *z          ,
                     MAP_OtherStateType            *otherState )  
{                                              
  int cnt = 0;                                 

  MAPUnpack( z, otherState->z_index, constrData->X_Len , constrData->X , &cnt);
  MAPUnpack( z, otherState->z_index, constrData->Y_Len , constrData->Y , &cnt);
  MAPUnpack( z, otherState->z_index, constrData->Z_Len , constrData->Z , &cnt);
  MAPUnpack( z, otherState->z_index, constrData->H_Len , constrData->H , &cnt);
  MAPUnpack( z, otherState->z_index, constrData->V_Len , constrData->V , &cnt);

  if( cnt != otherState->z_index_Len ) throw MAP_ERROR_76;
};


// ==========   UnpackInput   =======================================
//                                                            
// These functions are called at each time step to change/set values 
// inside the MAP classes (not exposed to Fortran). In the spirit of 
// the SetVaraibleArrayIndex(..) functions about, this step actually 
// sets values. 
//
// Variables __MUST__ be unpacked in this order:
//   
// X, Y, Z
void 
MAPUnpackInput( MAP_InputType       *inputData ,
                MAP_InputType_class *u         ,
                MAP_OtherStateType  *otherState )  
{                                              
  int cnt = 0;                                 

  // X fairlead displacement
  MAPUnpack( u, otherState->u_index, inputData->X_Len, inputData->X, &cnt);
  MAPUnpack( u, otherState->u_index, inputData->Y_Len, inputData->Y, &cnt);
  MAPUnpack( u, otherState->u_index, inputData->Z_Len, inputData->Z, &cnt);

  if( cnt != otherState->u_index_Len ) throw MAP_ERROR_75;
}                                              


// ==========   UnpackParameter   =======================================
//                                                            
// These functions are called at each time step to change/set values 
// inside the MAP classes (not exposed to Fortran). In the spirit of 
// the SetVaraibleArrayIndex(..) functions about, this step actually 
// sets values. 
//
// Variables __MUST__ be unpacked in this order:
//   
// Diam, MassDenInAir, EA, CB, Lu, X, Y, Z, FX, FY, FZ, M, B
void 
MAPUnpackParameter( MAP_ParameterType       *paramData ,
                    MAP_ParameterType_class *p         ,
                    MAP_OtherStateType      *otherState )  
{                                                                              
  int cnt = 0;                                                                 

  MAPUnpack( p, otherState->p_index, paramData->Diam_Len        , paramData->Diam        , &cnt);
  MAPUnpack( p, otherState->p_index, paramData->MassDenInAir_Len, paramData->MassDenInAir, &cnt);
  MAPUnpack( p, otherState->p_index, paramData->EA_Len          , paramData->EA          , &cnt);
  MAPUnpack( p, otherState->p_index, paramData->CB_Len          , paramData->CB          , &cnt);
  MAPUnpack( p, otherState->p_index, paramData->Lu_Len          , paramData->Lu          , &cnt);
  MAPUnpack( p, otherState->p_index, paramData->X_Len           , paramData->X           , &cnt);
  MAPUnpack( p, otherState->p_index, paramData->Y_Len           , paramData->Y           , &cnt);
  MAPUnpack( p, otherState->p_index, paramData->Z_Len           , paramData->Z           , &cnt);
  MAPUnpack( p, otherState->p_index, paramData->FX_Len          , paramData->FX          , &cnt);
  MAPUnpack( p, otherState->p_index, paramData->FY_Len          , paramData->FY          , &cnt);
  MAPUnpack( p, otherState->p_index, paramData->FZ_Len          , paramData->FZ          , &cnt);
  MAPUnpack( p, otherState->p_index, paramData->M_Len           , paramData->M           , &cnt);
  MAPUnpack( p, otherState->p_index, paramData->B_Len           , paramData->B           , &cnt);

  if( cnt != otherState->p_index_Len ) throw MAP_ERROR_74;
};                                                                              


/**
 *   UnpackOther  
 *                                                            
 * These functions are called at each time step to change/set values 
 * inside the MAP classes (not exposed to Fortran). In the spirit of 
 * the SetVaraibleArrayIndex(..) functions about, this step actually 
 * sets values. 
 *
 * Variables __MUST__ be unpacked in this order:
 *   
 * FX, FY, FZ
 */
void 
MAPUnpackOther( MAP_OtherStateType       *otherData ,
                MAP_OtherStateType_class *o         )                
{                                              
  int cnt = 0;                                 
  
  // FX node connect force
  MAPUnpack( o, otherData->o_index, otherData->FX_Len, otherData->FX, &cnt);
  MAPUnpack( o, otherData->o_index, otherData->FY_Len, otherData->FY, &cnt);
  MAPUnpack( o, otherData->o_index, otherData->FZ_Len, otherData->FZ, &cnt);

  if( cnt != otherData->o_index_Len ) throw MAP_ERROR_89;
}                                              


// ==========   Pack Input   =============================
//                                                            
// These functions are called at the end of the time step 
// to grab to new, recently calculated values inside the 
// MAP classes (to expose value to Fortran)                   
//
// Variables __MUST__ be packed in this order:
//   
// X, Y, Z
void 
MAPPackInput( MAP_InputType       *input ,
              MAP_InputType_class *u     ,
              MAP_OtherStateType  *otherState )
{                                                             
  int cnt = 0;                                                

  MAPPack( u, otherState->u_index, input->X_Len, input->X, &cnt);
  MAPPack( u, otherState->u_index, input->Y_Len, input->Y, &cnt);
  MAPPack( u, otherState->u_index, input->Z_Len, input->Z, &cnt);

  if( cnt != otherState->u_index_Len ) throw MAP_ERROR_73;
}


// ==========   Pack Output   =============================
//                                                            
// These functions are called at the end of the time step 
// to grab to new, recently calculated values inside the 
// MAP classes (to expose value to Fortran)                   
//
// Variables __MUST__ be packed in this order:
//   
// FX, FY, FZ
void 
MAPPackOutput( MAP_OutputType           *output     ,
               MAP_OutputType_class     *y          ,
               MAP_OtherStateType       *otherState ,
               MAP_OtherStateType_class *o          )
{                                                             
  int cnt = 0;                                                
  
  MAPPack( y, otherState->y_index, output->FX_Len, output->FX, &cnt);
  MAPPack( y, otherState->y_index, output->FY_Len, output->FY, &cnt);
  MAPPack( y, otherState->y_index, output->FZ_Len, output->FZ, &cnt);

  for(int i=0 ; i<output->FX_Len ; i++ ){
    output->FX[i] *= -1e3; // multiply by -1e-3 to convert from kN to N and get forces in FAST reference frame
    output->FY[i] *= -1e3; // multiply by -1e-3 to convert from kN to N and get forces in FAST reference frame
    output->FZ[i] *= -1e3; // multiply by -1e-3 to convert from kN to N and get forces in FAST reference frame
  }
  
  if( cnt != otherState->y_index_Len ) throw MAP_ERROR_71;

  // write output string to array
  for (int i=0 ; i< output->writeOutput_Len ; i++ ) {
    o->MAPCALL_GetWriteOutput( output->writeOutput, output->writeOutput_Len) ;
  }
}


// ==========   Pack Parameter   =============================
//                                                            
// These functions are called at the end of the time step 
// to grab to new, recently calculated values inside the 
// MAP classes (to expose value to Fortran)                   
//
// Variables __MUST__ be packed in this order:
//   
// Diam, MassDenInAir, EA, CB, Lu, X, Y, Z, FX, FY, FZ, M, B,
void 
MAPPackParameter( MAP_ParameterType       *paramData ,
                  MAP_ParameterType_class *p         ,
                  MAP_OtherStateType      *otherState )
{                                                             
  int cnt = 0;                                                

  MAPPack( p, otherState->p_index, paramData->Diam_Len        , paramData->Diam        , &cnt);
  MAPPack( p, otherState->p_index, paramData->MassDenInAir_Len, paramData->MassDenInAir, &cnt);
  MAPPack( p, otherState->p_index, paramData->EA_Len          , paramData->EA          , &cnt);
  MAPPack( p, otherState->p_index, paramData->CB_Len          , paramData->CB          , &cnt);
  MAPPack( p, otherState->p_index, paramData->Lu_Len          , paramData->Lu          , &cnt);
  MAPPack( p, otherState->p_index, paramData->X_Len           , paramData->X           , &cnt);
  MAPPack( p, otherState->p_index, paramData->Y_Len           , paramData->Y           , &cnt);
  MAPPack( p, otherState->p_index, paramData->Z_Len           , paramData->Z           , &cnt);
  MAPPack( p, otherState->p_index, paramData->FX_Len          , paramData->FX          , &cnt);
  MAPPack( p, otherState->p_index, paramData->FY_Len          , paramData->FY          , &cnt);
  MAPPack( p, otherState->p_index, paramData->FZ_Len          , paramData->FZ          , &cnt);
  MAPPack( p, otherState->p_index, paramData->M_Len           , paramData->M           , &cnt);
  MAPPack( p, otherState->p_index, paramData->B_Len           , paramData->B           , &cnt);

  if( cnt != otherState->p_index_Len ) throw MAP_ERROR_70;
};


// ==========   Pack Constraint   =============================
//                                                            
// These functions are called at the end of the time step 
// to grab to new, recently calculated values inside the 
// MAP classes (to expose value to Fortran)                   
//
// Variables __MUST__ be packed in this order:
//   
// X, Y, Z, H, V
void 
MAPPackConstraint( MAP_ConstraintStateType       *constrData ,
                   MAP_ConstraintStateType_class *z         ,
                   MAP_OtherStateType             *otherState )
{                                                             
  int cnt = 0;                                                

  MAPPack( z, otherState->z_index, constrData->X_Len, constrData->X, &cnt);
  MAPPack( z, otherState->z_index, constrData->Y_Len, constrData->Y, &cnt);
  MAPPack( z, otherState->z_index, constrData->Z_Len, constrData->Z, &cnt);
  MAPPack( z, otherState->z_index, constrData->H_Len, constrData->H, &cnt);
  MAPPack( z, otherState->z_index, constrData->V_Len, constrData->V, &cnt);

  if( cnt != otherState->z_index_Len ) throw MAP_ERROR_72;
};


//void 
//MAPSetInitOutputString( MAP_InitOutputType       *initOut ,
//                        MAP_InitOutputType_class *io      ,
//                        MAP_OtherStateType       *other   ,
//                        MAP_OtherStateType_class *o       )
//{
//  std::string tempStr = "";
//  const unsigned int MAX_CHARACTERS = 255; // size of MAP_OutputHeader and MAP_OutputUnits char array
//
//  // first copy the header (variable names)
//  tempStr = io->GetOutputHeader();
//  if ( MAX_CHARACTERS <= tempStr.length() ) throw MAP_ERROR_90;
//  else strcpy( initOut->writeOutputHeader, tempStr.c_str() );
//
//  // next copy the units
//  tempStr = io->GetOutputUnits();
//  if ( MAX_CHARACTERS <= tempStr.length() ) throw MAP_ERROR_90;
//  else strcpy( initOut->writeOutputUnits, tempStr.c_str() );
//}
