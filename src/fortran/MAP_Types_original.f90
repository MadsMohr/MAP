!STARTOFREGISTRYGENERATEDFILE './MAP_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry
! Do not edit.  Your changes to this file will be lost.
!
!*********************************************************************************************************************************
! MAP_Types
!.................................................................................................................................
! LICENSING
! Copyright (C) 2012 National Renewable Energy Laboratory
!
! This file is part of MAP.
!
! MAP is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as
! published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
!
! This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
! of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License along with ModuleName.
! If not, see <http://www.gnu.org/licenses/>.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************

MODULE MAP_Types
! This module contains all of the user-defined types needed in MAP. It also contains copy, destroy, pack, and
! unpack routines associated with each defined data type. This code will be generated by the FAST Registry.
!---------------------------------------------------------------------------------------------------------------------------------
  
  USE MAP_C_Types
  USE, INTRINSIC :: ISO_C_Binding  
  
  IMPLICIT NONE

  !==========   MAP_InitInputType   ======     <-----------------------------+  
  TYPE , BIND(C) :: MAP_InitInputType_C                           !          |
     TYPE     ( MAP_InitInput_C     ) :: class                    !          |
     TYPE   ( C_PTR       ) :: index      
     INTEGER(KIND=C_INT   ) :: indexLen       
     REAL     ( KIND=C_DOUBLE       ) :: gravity                  !          |
     REAL     ( KIND=C_DOUBLE       ) :: sea_density              !          |
     REAL     ( KIND=C_DOUBLE       ) :: depth                    !          |
     CHARACTER( KIND=C_CHAR,LEN=255 ) :: filename                 !          |
     CHARACTER( KIND=C_CHAR,LEN=255 ) :: cable_library_data       !          |
     CHARACTER( KIND=C_CHAR,LEN=255 ) :: node_data                !          |
     CHARACTER( KIND=C_CHAR,LEN=255 ) :: element_data             !          |
     CHARACTER( KIND=C_CHAR,LEN=255 ) :: solver_data              !          |
  END TYPE MAP_InitInputType_C                                    !          |
                                                                  !          |
  TYPE , PUBLIC  :: MAP_InitInputType                             !          |
     TYPE     ( MAP_InitInputType_C ) :: MAP_UserData             !          |
     INTEGER( KIND=C_INT )    , POINTER , DIMENSION(:) :: index=>NULL()
     INTEGER                                           :: indexLen 
     REAL                             :: gravity                  !          |
     REAL                             :: sea_density              !          |
     REAL                             :: depth                    !          |
     CHARACTER( 255                 ) :: filename                 !          |
     CHARACTER( 255                 ) :: cable_library_data       !          |
     CHARACTER( 255                 ) :: node_data                !          |
     CHARACTER( 255                 ) :: element_data             !          |
     CHARACTER( 255                 ) :: solver_data              !          |
  END TYPE MAP_InitInputType                                      !   -------+
  !===========================================================================


  !==========   MAP_InitOutputType   ======     <-----------------------------+  
  TYPE , BIND(C) :: MAP_InitOutputType_C            
     TYPE     ( MAP_InitOutput_C     ) :: class        
     TYPE   ( C_PTR       ) :: index      
     INTEGER(KIND=C_INT   ) :: indexLen       
     REAL     ( KIND=C_DOUBLE       ) :: dummy    
  END TYPE MAP_InitOutputType_C
                                                      
  TYPE , PUBLIC  :: MAP_InitOutputType           
     TYPE     ( MAP_InitOutputType_C ) :: MAP_UserData   
     INTEGER( KIND=C_INT )    , POINTER , DIMENSION(:) :: index=>NULL()
     INTEGER                                           :: indexLen 
     REAL                             :: dummy
  END TYPE MAP_InitOutputType                                      !   -------+
  !============================================================================


  !==========   MAP_ContinuousStateType   ======     <-----------------------+  
  TYPE , BIND(C) :: MAP_ContinuousStateType_C                     !          |
     TYPE( MAP_Continuous_C ) :: class                            !          |
     TYPE   ( C_PTR       ) :: index      
     INTEGER(KIND=C_INT   ) :: indexLen       
     REAL( KIND=C_DOUBLE )    :: Dummy                            !          |
  END TYPE MAP_ContinuousStateType_C                              !          |
                                                                  !          |
  TYPE, PUBLIC :: MAP_ContinuousStateType                         !          |
     TYPE( MAP_ContinuousStateType_C ) :: MAP_UserData            !          |
     INTEGER( KIND=C_INT )    , POINTER , DIMENSION(:) :: index=>NULL()
     INTEGER                                           :: indexLen 
     REAL :: Dummy                                                !          |
  END TYPE MAP_ContinuousStateType                                !   -------+
  !===========================================================================


  !==========   MAP_DiscreteStateType   ======     <-------------------------+  
  TYPE , BIND(C) :: MAP_DiscreteStateType_C                       !          |
     TYPE( MAP_Discrete_C )   :: class                            !          |
     TYPE   ( C_PTR       ) :: index      
     INTEGER(KIND=C_INT   ) :: indexLen       
     REAL( KIND=C_DOUBLE )    :: Dummy                            !          |
  END TYPE MAP_DiscreteStateType_C                                !          |
                                                                  !          |
  TYPE, PUBLIC :: MAP_DiscreteStateType                           !          |
     TYPE( MAP_DiscreteStateType_C ) :: MAP_UserData              !          |
     INTEGER( KIND=C_INT )    , POINTER , DIMENSION(:) :: index=>NULL()
     INTEGER                                           :: indexLen 
     REAL  :: Dummy                                               !          |
  END TYPE MAP_DiscreteStateType                                  !   -------+
  !===========================================================================


  !==========   MAP_OtherStateType   ======   
  TYPE , BIND(C) :: MAP_OtherStateType_C      
     TYPE(MAP_Other_C)   :: class             
     TYPE   ( C_PTR       ) :: index      
     INTEGER(KIND=C_INT   ) :: indexLen       
     TYPE( C_PTR ) :: FX                      
     TYPE( C_PTR ) :: FY                      
     TYPE( C_PTR ) :: FZ                      
     INTEGER( KIND=C_INT ) :: FXlen           
     INTEGER( KIND=C_INT ) :: FYlen           
     INTEGER( KIND=C_INT ) :: FZlen           
     TYPE( C_PTR ) :: PLOT_flag                    
     TYPE( C_PTR ) :: X_POS_flag                   
     TYPE( C_PTR ) :: Y_POS_flag                   
     TYPE( C_PTR ) :: Z_POS_flag                   
     TYPE( C_PTR ) :: X_FORCE_flag                 
     TYPE( C_PTR ) :: Y_FORCE_flag                 
     TYPE( C_PTR ) :: Z_FORCE_flag                 
     TYPE( C_PTR ) :: LINE_TENSION_flag            
     TYPE( C_PTR ) :: OMIT_CONTACT_flag            
     TYPE( C_PTR ) :: LAY_LENGTH_flag              
     INTEGER( KIND=C_INT ) :: PLOT_flaglen         
     INTEGER( KIND=C_INT ) :: X_POS_flaglen        
     INTEGER( KIND=C_INT ) :: Y_POS_flaglen        
     INTEGER( KIND=C_INT ) :: Z_POS_flaglen        
     INTEGER( KIND=C_INT ) :: X_FORCE_flaglen      
     INTEGER( KIND=C_INT ) :: Y_FORCE_flaglen      
     INTEGER( KIND=C_INT ) :: Z_FORCE_flaglen      
     INTEGER( KIND=C_INT ) :: LINE_TENSION_flaglen 
     INTEGER( KIND=C_INT ) :: OMIT_CONTACT_flaglen 
     INTEGER( KIND=C_INT ) :: LAY_LENGTH_flaglen   
  END TYPE MAP_OtherStateType_C                                   
                                                                  
  TYPE, PUBLIC :: MAP_OtherStateType                              
     TYPE(MAP_OtherStateType_C) :: MAP_UserData                          
     INTEGER( KIND=C_INT )    , POINTER , DIMENSION(:) :: index=>NULL()
     INTEGER                                           :: indexLen 
     REAL( KIND=C_DOUBLE ) , POINTER , DIMENSION(:) :: FX=>NULL() 
     REAL( KIND=C_DOUBLE ) , POINTER , DIMENSION(:) :: FY=>NULL() 
     REAL( KIND=C_DOUBLE ) , POINTER , DIMENSION(:) :: FZ=>NULL() 
     INTEGER :: FXlen                                             
     INTEGER :: FYlen                                             
     INTEGER :: FZlen                                             
     LOGICAL( KIND=C_BOOL ) , POINTER , DIMENSION(:) :: PLOT_flag=>NULL()
     LOGICAL( KIND=C_BOOL ) , POINTER , DIMENSION(:) :: X_POS_flag=>NULL()
     LOGICAL( KIND=C_BOOL ) , POINTER , DIMENSION(:) :: Y_POS_flag=>NULL()
     LOGICAL( KIND=C_BOOL ) , POINTER , DIMENSION(:) :: Z_POS_flag=>NULL()
     LOGICAL( KIND=C_BOOL ) , POINTER , DIMENSION(:) :: X_FORCE_flag=>NULL()
     LOGICAL( KIND=C_BOOL ) , POINTER , DIMENSION(:) :: Y_FORCE_flag=>NULL()
     LOGICAL( KIND=C_BOOL ) , POINTER , DIMENSION(:) :: Z_FORCE_flag=>NULL()
     LOGICAL( KIND=C_BOOL ) , POINTER , DIMENSION(:) :: LINE_TENSION_flag=>NULL()
     LOGICAL( KIND=C_BOOL ) , POINTER , DIMENSION(:) :: OMIT_CONTACT_flag=>NULL()
     LOGICAL( KIND=C_BOOL ) , POINTER , DIMENSION(:) :: LAY_LENGTH_flag=>NULL()
     INTEGER :: PLOT_flaglen                 
     INTEGER :: X_POS_flaglen                
     INTEGER :: Y_POS_flaglen                
     INTEGER :: Z_POS_flaglen                
     INTEGER :: X_FORCE_flaglen              
     INTEGER :: Y_FORCE_flaglen              
     INTEGER :: Z_FORCE_flaglen              
     INTEGER :: LINE_TENSION_flaglen         
     INTEGER :: OMIT_CONTACT_flaglen         
     INTEGER :: LAY_LENGTH_flaglen           
  END TYPE MAP_OtherStateType                                     
  !===========================================================================


  !==========   MAP_ConstraintStateType   ======     
  TYPE , BIND(C) :: MAP_ConstraintStateType_C      
     TYPE   ( MAP_Constraint_C ) :: class          
     TYPE   ( C_PTR       ) :: index      
     INTEGER(KIND=C_INT   ) :: indexLen       
     TYPE   ( C_PTR ) :: X                         
     TYPE   ( C_PTR ) :: Y                         
     TYPE   ( C_PTR ) :: Z                         
     TYPE   ( C_PTR ) :: H                         
     TYPE   ( C_PTR ) :: V                         
     INTEGER( KIND=C_INT ) :: XLen       
     INTEGER( KIND=C_INT ) :: YLen       
     INTEGER( KIND=C_INT ) :: ZLen       
     INTEGER( KIND=C_INT ) :: HLen       
     INTEGER( KIND=C_INT ) :: VLen       
  END TYPE MAP_ConstraintStateType_C               
                                                   
  TYPE, PUBLIC :: MAP_ConstraintStateType          
     TYPE ( MAP_ConstraintStateType_C ) :: MAP_UserData   
     INTEGER( KIND=C_INT )    , POINTER , DIMENSION(:) :: index=>NULL()
     INTEGER                                           :: indexLen 
     REAL ( KIND=C_DOUBLE ) , POINTER , DIMENSION(:) :: X=>NULL()
     REAL ( KIND=C_DOUBLE ) , POINTER , DIMENSION(:) :: Y=>NULL()
     REAL ( KIND=C_DOUBLE ) , POINTER , DIMENSION(:) :: Z=>NULL()
     REAL ( KIND=C_DOUBLE ) , POINTER , DIMENSION(:) :: H=>NULL()
     REAL ( KIND=C_DOUBLE ) , POINTER , DIMENSION(:) :: V=>NULL()
     INTEGER :: XLen                                            
     INTEGER :: YLen                                            
     INTEGER :: ZLen                                            
     INTEGER :: HLen                                            
     INTEGER :: VLen                                            
  END TYPE MAP_ConstraintStateType                               
  !===========================================================================

  !==========   MAP_ParameterType   ======  
  TYPE , BIND(C) :: MAP_ParameterType_C               
     TYPE( MAP_Parameter_C ) :: class                 
     TYPE   ( C_PTR       ) :: index      
     INTEGER(KIND=C_INT   ) :: indexLen       
     TYPE( C_PTR ) :: Diam                            
     TYPE( C_PTR ) :: MassDenInAir                    
     TYPE( C_PTR ) :: EA                              
     TYPE( C_PTR ) :: CB                              
     TYPE( C_PTR ) :: Lu                              
     INTEGER( KIND=C_INT ) :: DiamLen       
     INTEGER( KIND=C_INT ) :: MassDenInAirLen       
     INTEGER( KIND=C_INT ) :: EALen       
     INTEGER( KIND=C_INT ) :: CBLen       
     INTEGER( KIND=C_INT ) :: LuLen       
  END TYPE MAP_ParameterType_C                        
                                                      
  TYPE, PUBLIC :: MAP_ParameterType                   
     TYPE( MAP_ParameterType_C )  :: MAP_UserData            
     INTEGER( KIND=C_INT )    , POINTER , DIMENSION(:) :: index=>NULL()
     INTEGER                                           :: indexLen 
     REAL( KIND=C_DOUBLE ) , POINTER , DIMENSION(:) :: Diam=>NULL()
     REAL( KIND=C_DOUBLE ) , POINTER , DIMENSION(:) :: MassDenInAir=>NULL()
     REAL( KIND=C_DOUBLE ) , POINTER , DIMENSION(:) :: EA=>NULL()
     REAL( KIND=C_DOUBLE ) , POINTER , DIMENSION(:) :: CB=>NULL()
     REAL( KIND=C_DOUBLE ) , POINTER , DIMENSION(:) :: Lu=>NULL()
     INTEGER :: DiamLen                                            
     INTEGER :: MassDenInAirLen                                            
     INTEGER :: EALen                                            
     INTEGER :: CBLen                                            
     INTEGER :: LuLen                                            
  END TYPE MAP_ParameterType                                      !   -------+
  !===========================================================================


  !==========   MAP_InputType   ======     
  TYPE , BIND(C) :: MAP_InputType_C        
     TYPE   ( MAP_Input_C ) :: class       
     TYPE   ( C_PTR       ) :: index      
     INTEGER(KIND=C_INT   ) :: indexLen       
     TYPE   ( C_PTR       ) :: X           
     TYPE   ( C_PTR       ) :: Y           
     TYPE   ( C_PTR       ) :: Z           
     INTEGER( KIND=C_INT ) :: XLen       
     INTEGER( KIND=C_INT ) :: YLen       
     INTEGER( KIND=C_INT ) :: ZLen       
  END TYPE MAP_InputType_C                 
                                           
  TYPE , PUBLIC  :: MAP_InputType          
     TYPE   ( MAP_InputType_C )                        :: MAP_UserData
     INTEGER( KIND=C_INT )    , POINTER , DIMENSION(:) :: index=>NULL()
     INTEGER                                           :: indexLen 
     REAL   ( KIND=C_DOUBLE ) , POINTER , DIMENSION(:) :: X=>NULL()   
     REAL   ( KIND=C_DOUBLE ) , POINTER , DIMENSION(:) :: Y=>NULL()
     REAL   ( KIND=C_DOUBLE ) , POINTER , DIMENSION(:) :: Z=>NULL()
     INTEGER :: XLen                                            
     INTEGER :: YLen                                            
     INTEGER :: ZLen                                            
  END TYPE MAP_InputType                                          
  !===========================================================================


  !==========   MAP_OutputType   ======   
  TYPE , BIND(C) :: MAP_OutputType_C      
     TYPE( MAP_Output_C ) :: class        
     TYPE   ( C_PTR       ) :: index      
     INTEGER(KIND=C_INT   ) :: indexLen       
     TYPE( C_PTR ) :: FX                  
     TYPE( C_PTR ) :: FY                  
     TYPE( C_PTR ) :: FZ                  
     INTEGER( KIND=C_INT ) :: FXLen       
     INTEGER( KIND=C_INT ) :: FYLen       
     INTEGER( KIND=C_INT ) :: FZLen       
  END TYPE MAP_OutputType_C               
                                          
  TYPE, PUBLIC :: MAP_OutputType          
     TYPE( MAP_OutputType_C ) :: MAP_UserData    
     INTEGER( KIND=C_INT )    , POINTER , DIMENSION(:) :: index=>NULL()
     INTEGER                                           :: indexLen 
     REAL( KIND=C_DOUBLE ) , POINTER , DIMENSION(:) :: FX=>NULL() 
     REAL( KIND=C_DOUBLE ) , POINTER , DIMENSION(:) :: FY=>NULL() 
     REAL( KIND=C_DOUBLE ) , POINTER , DIMENSION(:) :: FZ=>NULL() 
     INTEGER :: FXLen                                            
     INTEGER :: FYLen                                            
     INTEGER :: FZLen                                            
  END TYPE MAP_OutputType                                        
  !===========================================================================


!CONTAINS
!
! SUBROUTINE MAP_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
!  TYPE(MAP_initinputtype), INTENT(INOUT) :: SrcInitInputData
!  TYPE(MAP_initinputtype), INTENT(  OUT) :: DstInitInputData
!  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
!  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
!  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
!! Local 
!  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
!! 
!  ErrStat = ErrID_None
!  ErrMsg  = ""
!  i1 = SIZE(SrcInitInputData%cable_library_data,1)
!  IF (.NOT.ALLOCATED(DstInitInputData%cable_library_data)) ALLOCATE(DstInitInputData%cable_library_data(i1))
!  DstInitInputData%cable_library_data = SrcInitInputData%cable_library_data
!  i1 = SIZE(SrcInitInputData%element_data,1)
!  IF (.NOT.ALLOCATED(DstInitInputData%element_data)) ALLOCATE(DstInitInputData%element_data(i1))
!  DstInitInputData%element_data = SrcInitInputData%element_data
!  i1 = SIZE(SrcInitInputData%node_data,1)
!  IF (.NOT.ALLOCATED(DstInitInputData%node_data)) ALLOCATE(DstInitInputData%node_data(i1))
!  DstInitInputData%node_data = SrcInitInputData%node_data
!  i1 = SIZE(SrcInitInputData%solver_options,1)
!  IF (.NOT.ALLOCATED(DstInitInputData%solver_options)) ALLOCATE(DstInitInputData%solver_options(i1))
!  DstInitInputData%solver_options = SrcInitInputData%solver_options
!  DstInitInputData%gravity = SrcInitInputData%gravity
!  DstInitInputData%sea_density = SrcInitInputData%sea_density
!  DstInitInputData%depth = SrcInitInputData%depth
! END SUBROUTINE MAP_CopyInitInput
!
! SUBROUTINE MAP_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
!  TYPE(MAP_initinputtype), INTENT(INOUT) :: InitInputData
!  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
!  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
!  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
!! 
!  ErrStat = ErrID_None
!  ErrMsg  = ""
!  IF ( ALLOCATED(InitInputData%cable_library_data) ) DEALLOCATE(InitInputData%cable_library_data)
!  IF ( ALLOCATED(InitInputData%element_data) ) DEALLOCATE(InitInputData%element_data)
!  IF ( ALLOCATED(InitInputData%node_data) ) DEALLOCATE(InitInputData%node_data)
!  IF ( ALLOCATED(InitInputData%solver_options) ) DEALLOCATE(InitInputData%solver_options)
! END SUBROUTINE MAP_DestroyInitInput
!
! SUBROUTINE MAP_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
!  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
!  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
!  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
!  TYPE(MAP_initinputtype),  INTENT(INOUT) :: InData
!  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
!  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
!  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
!    ! Local variables
!  INTEGER(IntKi)                 :: Re_BufSz
!  INTEGER(IntKi)                 :: Re_Xferred
!  INTEGER(IntKi)                 :: Re_CurrSz
!  INTEGER(IntKi)                 :: Db_BufSz
!  INTEGER(IntKi)                 :: Db_Xferred
!  INTEGER(IntKi)                 :: Db_CurrSz
!  INTEGER(IntKi)                 :: Int_BufSz
!  INTEGER(IntKi)                 :: Int_Xferred
!  INTEGER(IntKi)                 :: Int_CurrSz
!  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
!  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
! ! buffers to store meshes, if any
!  OnlySize = .FALSE.
!  IF ( PRESENT(SizeOnly) ) THEN
!    OnlySize = SizeOnly
!  ENDIF
!    !
!  ErrStat = ErrID_None
!  ErrMsg  = ""
!  Re_Xferred  = 1
!  Db_Xferred  = 1
!  Int_Xferred  = 1
!  Re_BufSz  = 0
!  Db_BufSz  = 0
!  Int_BufSz  = 0
!  Re_BufSz   = Re_BufSz   + 1  ! gravity
!  Re_BufSz   = Re_BufSz   + 1  ! sea_density
!  Re_BufSz   = Re_BufSz   + 1  ! depth
!  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
!  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
!  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
!  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%gravity )
!  Re_Xferred   = Re_Xferred   + 1
!  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%sea_density )
!  Re_Xferred   = Re_Xferred   + 1
!  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%depth )
!  Re_Xferred   = Re_Xferred   + 1
! END SUBROUTINE MAP_PackInitInput
!
! SUBROUTINE MAP_UnpackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
!  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
!  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
!  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
!  TYPE(MAP_initinputtype), INTENT(INOUT) :: OutData
!  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
!  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
!    ! Local variables
!  INTEGER(IntKi)                 :: Re_BufSz
!  INTEGER(IntKi)                 :: Re_Xferred
!  INTEGER(IntKi)                 :: Re_CurrSz
!  INTEGER(IntKi)                 :: Db_BufSz
!  INTEGER(IntKi)                 :: Db_Xferred
!  INTEGER(IntKi)                 :: Db_CurrSz
!  INTEGER(IntKi)                 :: Int_BufSz
!  INTEGER(IntKi)                 :: Int_Xferred
!  INTEGER(IntKi)                 :: Int_CurrSz
!  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
!  LOGICAL, ALLOCATABLE           :: mask1(:)
!  LOGICAL, ALLOCATABLE           :: mask2(:,:)
!  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
!  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
!  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
! ! buffers to store meshes, if any
!    !
!  ErrStat = ErrID_None
!  ErrMsg  = ""
!  Re_Xferred  = 1
!  Db_Xferred  = 1
!  Int_Xferred  = 1
!  Re_BufSz  = 0
!  Db_BufSz  = 0
!  Int_BufSz  = 0
!  OutData%gravity = ReKiBuf ( Re_Xferred )
!  Re_Xferred   = Re_Xferred   + 1
!  OutData%sea_density = ReKiBuf ( Re_Xferred )
!  Re_Xferred   = Re_Xferred   + 1
!  OutData%depth = ReKiBuf ( Re_Xferred )
!  Re_Xferred   = Re_Xferred   + 1
!  Re_Xferred   = Re_Xferred-1
!  Db_Xferred   = Db_Xferred-1
!  Int_Xferred  = Int_Xferred-1
! END SUBROUTINE MAP_UnpackInitInput
!
! SUBROUTINE MAP_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
!  TYPE(MAP_inputtype), INTENT(INOUT) :: SrcInputData
!  TYPE(MAP_inputtype), INTENT(  OUT) :: DstInputData
!  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
!  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
!  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
!! Local 
!  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
!! 
!  ErrStat = ErrID_None
!  ErrMsg  = ""
!  i1 = SIZE(SrcInputData%X,1)
!  IF (.NOT.ALLOCATED(DstInputData%X)) ALLOCATE(DstInputData%X(i1))
!  DstInputData%X = SrcInputData%X
!  i1 = SIZE(SrcInputData%Y,1)
!  IF (.NOT.ALLOCATED(DstInputData%Y)) ALLOCATE(DstInputData%Y(i1))
!  DstInputData%Y = SrcInputData%Y
!  i1 = SIZE(SrcInputData%Z,1)
!  IF (.NOT.ALLOCATED(DstInputData%Z)) ALLOCATE(DstInputData%Z(i1))
!  DstInputData%Z = SrcInputData%Z
! END SUBROUTINE MAP_CopyInput
!
! SUBROUTINE MAP_DestroyInput( InputData, ErrStat, ErrMsg )
!  TYPE(MAP_inputtype), INTENT(INOUT) :: InputData
!  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
!  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
!  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
!! 
!  ErrStat = ErrID_None
!  ErrMsg  = ""
!  IF ( ALLOCATED(InputData%X) ) DEALLOCATE(InputData%X)
!  IF ( ALLOCATED(InputData%Y) ) DEALLOCATE(InputData%Y)
!  IF ( ALLOCATED(InputData%Z) ) DEALLOCATE(InputData%Z)
! END SUBROUTINE MAP_DestroyInput
!
! SUBROUTINE MAP_PackInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
!  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
!  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
!  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
!  TYPE(MAP_inputtype),  INTENT(INOUT) :: InData
!  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
!  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
!  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
!    ! Local variables
!  INTEGER(IntKi)                 :: Re_BufSz
!  INTEGER(IntKi)                 :: Re_Xferred
!  INTEGER(IntKi)                 :: Re_CurrSz
!  INTEGER(IntKi)                 :: Db_BufSz
!  INTEGER(IntKi)                 :: Db_Xferred
!  INTEGER(IntKi)                 :: Db_CurrSz
!  INTEGER(IntKi)                 :: Int_BufSz
!  INTEGER(IntKi)                 :: Int_Xferred
!  INTEGER(IntKi)                 :: Int_CurrSz
!  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
!  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
! ! buffers to store meshes, if any
!  OnlySize = .FALSE.
!  IF ( PRESENT(SizeOnly) ) THEN
!    OnlySize = SizeOnly
!  ENDIF
!    !
!  ErrStat = ErrID_None
!  ErrMsg  = ""
!  Re_Xferred  = 1
!  Db_Xferred  = 1
!  Int_Xferred  = 1
!  Re_BufSz  = 0
!  Db_BufSz  = 0
!  Int_BufSz  = 0
!  Re_BufSz    = Re_BufSz    + SIZE( InData%X )  ! X 
!  Re_BufSz    = Re_BufSz    + SIZE( InData%Y )  ! Y 
!  Re_BufSz    = Re_BufSz    + SIZE( InData%Z )  ! Z 
!  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
!  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
!  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
!  IF ( ALLOCATED(InData%X) ) THEN
!    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%X))-1 ) =  PACK(InData%X ,.TRUE.)
!    Re_Xferred   = Re_Xferred   + SIZE(InData%X)
!  ENDIF
!  IF ( ALLOCATED(InData%Y) ) THEN
!    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Y))-1 ) =  PACK(InData%Y ,.TRUE.)
!    Re_Xferred   = Re_Xferred   + SIZE(InData%Y)
!  ENDIF
!  IF ( ALLOCATED(InData%Z) ) THEN
!    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Z))-1 ) =  PACK(InData%Z ,.TRUE.)
!    Re_Xferred   = Re_Xferred   + SIZE(InData%Z)
!  ENDIF
! END SUBROUTINE MAP_PackInput
!
! SUBROUTINE MAP_UnpackInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
!  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
!  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
!  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
!  TYPE(MAP_inputtype), INTENT(INOUT) :: OutData
!  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
!  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
!    ! Local variables
!  INTEGER(IntKi)                 :: Re_BufSz
!  INTEGER(IntKi)                 :: Re_Xferred
!  INTEGER(IntKi)                 :: Re_CurrSz
!  INTEGER(IntKi)                 :: Db_BufSz
!  INTEGER(IntKi)                 :: Db_Xferred
!  INTEGER(IntKi)                 :: Db_CurrSz
!  INTEGER(IntKi)                 :: Int_BufSz
!  INTEGER(IntKi)                 :: Int_Xferred
!  INTEGER(IntKi)                 :: Int_CurrSz
!  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
!  LOGICAL, ALLOCATABLE           :: mask1(:)
!  LOGICAL, ALLOCATABLE           :: mask2(:,:)
!  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
!  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
!  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
! ! buffers to store meshes, if any
!    !
!  ErrStat = ErrID_None
!  ErrMsg  = ""
!  Re_Xferred  = 1
!  Db_Xferred  = 1
!  Int_Xferred  = 1
!  Re_BufSz  = 0
!  Db_BufSz  = 0
!  Int_BufSz  = 0
!  IF ( ALLOCATED(OutData%X) ) THEN
!  ALLOCATE(mask1(SIZE(OutData%X,1))); mask1 = .TRUE.
!    OutData%X = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%X))-1 ),mask1,OutData%X)
!  DEALLOCATE(mask1)
!    Re_Xferred   = Re_Xferred   + SIZE(OutData%X)
!  ENDIF
!  IF ( ALLOCATED(OutData%Y) ) THEN
!  ALLOCATE(mask1(SIZE(OutData%Y,1))); mask1 = .TRUE.
!    OutData%Y = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Y))-1 ),mask1,OutData%Y)
!  DEALLOCATE(mask1)
!    Re_Xferred   = Re_Xferred   + SIZE(OutData%Y)
!  ENDIF
!  IF ( ALLOCATED(OutData%Z) ) THEN
!  ALLOCATE(mask1(SIZE(OutData%Z,1))); mask1 = .TRUE.
!    OutData%Z = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Z))-1 ),mask1,OutData%Z)
!  DEALLOCATE(mask1)
!    Re_Xferred   = Re_Xferred   + SIZE(OutData%Z)
!  ENDIF
!  Re_Xferred   = Re_Xferred-1
!  Db_Xferred   = Db_Xferred-1
!  Int_Xferred  = Int_Xferred-1
! END SUBROUTINE MAP_UnpackInput
!
! SUBROUTINE MAP_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
!  TYPE(MAP_continuousstatetype), INTENT(INOUT) :: SrcContStateData
!  TYPE(MAP_continuousstatetype), INTENT(  OUT) :: DstContStateData
!  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
!  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
!  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
!! Local 
!  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
!! 
!  ErrStat = ErrID_None
!  ErrMsg  = ""
!  i1 = SIZE(SrcContStateData%Dummy,1)
!  IF (.NOT.ALLOCATED(DstContStateData%Dummy)) ALLOCATE(DstContStateData%Dummy(i1))
!  DstContStateData%Dummy = SrcContStateData%Dummy
! END SUBROUTINE MAP_CopyContState
!
! SUBROUTINE MAP_DestroyContState( ContStateData, ErrStat, ErrMsg )
!  TYPE(MAP_continuousstatetype), INTENT(INOUT) :: ContStateData
!  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
!  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
!  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
!! 
!  ErrStat = ErrID_None
!  ErrMsg  = ""
!  IF ( ALLOCATED(ContStateData%Dummy) ) DEALLOCATE(ContStateData%Dummy)
! END SUBROUTINE MAP_DestroyContState
!
! SUBROUTINE MAP_PackContState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
!  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
!  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
!  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
!  TYPE(MAP_continuousstatetype),  INTENT(INOUT) :: InData
!  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
!  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
!  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
!    ! Local variables
!  INTEGER(IntKi)                 :: Re_BufSz
!  INTEGER(IntKi)                 :: Re_Xferred
!  INTEGER(IntKi)                 :: Re_CurrSz
!  INTEGER(IntKi)                 :: Db_BufSz
!  INTEGER(IntKi)                 :: Db_Xferred
!  INTEGER(IntKi)                 :: Db_CurrSz
!  INTEGER(IntKi)                 :: Int_BufSz
!  INTEGER(IntKi)                 :: Int_Xferred
!  INTEGER(IntKi)                 :: Int_CurrSz
!  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
!  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
! ! buffers to store meshes, if any
!  OnlySize = .FALSE.
!  IF ( PRESENT(SizeOnly) ) THEN
!    OnlySize = SizeOnly
!  ENDIF
!    !
!  ErrStat = ErrID_None
!  ErrMsg  = ""
!  Re_Xferred  = 1
!  Db_Xferred  = 1
!  Int_Xferred  = 1
!  Re_BufSz  = 0
!  Db_BufSz  = 0
!  Int_BufSz  = 0
!  Re_BufSz    = Re_BufSz    + SIZE( InData%Dummy )  ! Dummy 
!  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
!  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
!  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
!  IF ( ALLOCATED(InData%Dummy) ) THEN
!    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Dummy))-1 ) =  PACK(InData%Dummy ,.TRUE.)
!    Re_Xferred   = Re_Xferred   + SIZE(InData%Dummy)
!  ENDIF
! END SUBROUTINE MAP_PackContState
!
! SUBROUTINE MAP_UnpackContState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
!  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
!  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
!  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
!  TYPE(MAP_continuousstatetype), INTENT(INOUT) :: OutData
!  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
!  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
!    ! Local variables
!  INTEGER(IntKi)                 :: Re_BufSz
!  INTEGER(IntKi)                 :: Re_Xferred
!  INTEGER(IntKi)                 :: Re_CurrSz
!  INTEGER(IntKi)                 :: Db_BufSz
!  INTEGER(IntKi)                 :: Db_Xferred
!  INTEGER(IntKi)                 :: Db_CurrSz
!  INTEGER(IntKi)                 :: Int_BufSz
!  INTEGER(IntKi)                 :: Int_Xferred
!  INTEGER(IntKi)                 :: Int_CurrSz
!  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
!  LOGICAL, ALLOCATABLE           :: mask1(:)
!  LOGICAL, ALLOCATABLE           :: mask2(:,:)
!  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
!  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
!  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
! ! buffers to store meshes, if any
!    !
!  ErrStat = ErrID_None
!  ErrMsg  = ""
!  Re_Xferred  = 1
!  Db_Xferred  = 1
!  Int_Xferred  = 1
!  Re_BufSz  = 0
!  Db_BufSz  = 0
!  Int_BufSz  = 0
!  IF ( ALLOCATED(OutData%Dummy) ) THEN
!  ALLOCATE(mask1(SIZE(OutData%Dummy,1))); mask1 = .TRUE.
!    OutData%Dummy = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Dummy))-1 ),mask1,OutData%Dummy)
!  DEALLOCATE(mask1)
!    Re_Xferred   = Re_Xferred   + SIZE(OutData%Dummy)
!  ENDIF
!  Re_Xferred   = Re_Xferred-1
!  Db_Xferred   = Db_Xferred-1
!  Int_Xferred  = Int_Xferred-1
! END SUBROUTINE MAP_UnpackContState
!
! SUBROUTINE MAP_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
!  TYPE(MAP_discretestatetype), INTENT(INOUT) :: SrcDiscStateData
!  TYPE(MAP_discretestatetype), INTENT(  OUT) :: DstDiscStateData
!  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
!  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
!  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
!! Local 
!  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
!! 
!  ErrStat = ErrID_None
!  ErrMsg  = ""
!  DstDiscStateData%Dummy = SrcDiscStateData%Dummy
! END SUBROUTINE MAP_CopyDiscState
!
! SUBROUTINE MAP_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
!  TYPE(MAP_discretestatetype), INTENT(INOUT) :: DiscStateData
!  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
!  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
!  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
!! 
!  ErrStat = ErrID_None
!  ErrMsg  = ""
! END SUBROUTINE MAP_DestroyDiscState
!
! SUBROUTINE MAP_PackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
!  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
!  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
!  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
!  TYPE(MAP_discretestatetype),  INTENT(INOUT) :: InData
!  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
!  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
!  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
!    ! Local variables
!  INTEGER(IntKi)                 :: Re_BufSz
!  INTEGER(IntKi)                 :: Re_Xferred
!  INTEGER(IntKi)                 :: Re_CurrSz
!  INTEGER(IntKi)                 :: Db_BufSz
!  INTEGER(IntKi)                 :: Db_Xferred
!  INTEGER(IntKi)                 :: Db_CurrSz
!  INTEGER(IntKi)                 :: Int_BufSz
!  INTEGER(IntKi)                 :: Int_Xferred
!  INTEGER(IntKi)                 :: Int_CurrSz
!  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
!  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
! ! buffers to store meshes, if any
!  OnlySize = .FALSE.
!  IF ( PRESENT(SizeOnly) ) THEN
!    OnlySize = SizeOnly
!  ENDIF
!    !
!  ErrStat = ErrID_None
!  ErrMsg  = ""
!  Re_Xferred  = 1
!  Db_Xferred  = 1
!  Int_Xferred  = 1
!  Re_BufSz  = 0
!  Db_BufSz  = 0
!  Int_BufSz  = 0
!  Re_BufSz   = Re_BufSz   + 1  ! Dummy
!  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
!  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
!  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
!  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Dummy )
!  Re_Xferred   = Re_Xferred   + 1
! END SUBROUTINE MAP_PackDiscState
!
! SUBROUTINE MAP_UnpackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
!  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
!  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
!  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
!  TYPE(MAP_discretestatetype), INTENT(INOUT) :: OutData
!  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
!  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
!    ! Local variables
!  INTEGER(IntKi)                 :: Re_BufSz
!  INTEGER(IntKi)                 :: Re_Xferred
!  INTEGER(IntKi)                 :: Re_CurrSz
!  INTEGER(IntKi)                 :: Db_BufSz
!  INTEGER(IntKi)                 :: Db_Xferred
!  INTEGER(IntKi)                 :: Db_CurrSz
!  INTEGER(IntKi)                 :: Int_BufSz
!  INTEGER(IntKi)                 :: Int_Xferred
!  INTEGER(IntKi)                 :: Int_CurrSz
!  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
!  LOGICAL, ALLOCATABLE           :: mask1(:)
!  LOGICAL, ALLOCATABLE           :: mask2(:,:)
!  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
!  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
!  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
! ! buffers to store meshes, if any
!    !
!  ErrStat = ErrID_None
!  ErrMsg  = ""
!  Re_Xferred  = 1
!  Db_Xferred  = 1
!  Int_Xferred  = 1
!  Re_BufSz  = 0
!  Db_BufSz  = 0
!  Int_BufSz  = 0
!  OutData%Dummy = ReKiBuf ( Re_Xferred )
!  Re_Xferred   = Re_Xferred   + 1
!  Re_Xferred   = Re_Xferred-1
!  Db_Xferred   = Db_Xferred-1
!  Int_Xferred  = Int_Xferred-1
! END SUBROUTINE MAP_UnpackDiscState
!
! SUBROUTINE MAP_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
!  TYPE(MAP_constraintstatetype), INTENT(INOUT) :: SrcConstrStateData
!  TYPE(MAP_constraintstatetype), INTENT(  OUT) :: DstConstrStateData
!  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
!  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
!  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
!! Local 
!  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
!! 
!  ErrStat = ErrID_None
!  ErrMsg  = ""
!  i1 = SIZE(SrcConstrStateData%X,1)
!  IF (.NOT.ALLOCATED(DstConstrStateData%X)) ALLOCATE(DstConstrStateData%X(i1))
!  DstConstrStateData%X = SrcConstrStateData%X
!  i1 = SIZE(SrcConstrStateData%Y,1)
!  IF (.NOT.ALLOCATED(DstConstrStateData%Y)) ALLOCATE(DstConstrStateData%Y(i1))
!  DstConstrStateData%Y = SrcConstrStateData%Y
!  i1 = SIZE(SrcConstrStateData%Z,1)
!  IF (.NOT.ALLOCATED(DstConstrStateData%Z)) ALLOCATE(DstConstrStateData%Z(i1))
!  DstConstrStateData%Z = SrcConstrStateData%Z
!  i1 = SIZE(SrcConstrStateData%FX,1)
!  IF (.NOT.ALLOCATED(DstConstrStateData%FX)) ALLOCATE(DstConstrStateData%FX(i1))
!  DstConstrStateData%FX = SrcConstrStateData%FX
!  i1 = SIZE(SrcConstrStateData%FY,1)
!  IF (.NOT.ALLOCATED(DstConstrStateData%FY)) ALLOCATE(DstConstrStateData%FY(i1))
!  DstConstrStateData%FY = SrcConstrStateData%FY
!  i1 = SIZE(SrcConstrStateData%FZ,1)
!  IF (.NOT.ALLOCATED(DstConstrStateData%FZ)) ALLOCATE(DstConstrStateData%FZ(i1))
!  DstConstrStateData%FZ = SrcConstrStateData%FZ
! END SUBROUTINE MAP_CopyConstrState
!
! SUBROUTINE MAP_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
!  TYPE(MAP_constraintstatetype), INTENT(INOUT) :: ConstrStateData
!  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
!  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
!  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
!! 
!  ErrStat = ErrID_None
!  ErrMsg  = ""
!  IF ( ALLOCATED(ConstrStateData%X) ) DEALLOCATE(ConstrStateData%X)
!  IF ( ALLOCATED(ConstrStateData%Y) ) DEALLOCATE(ConstrStateData%Y)
!  IF ( ALLOCATED(ConstrStateData%Z) ) DEALLOCATE(ConstrStateData%Z)
!  IF ( ALLOCATED(ConstrStateData%FX) ) DEALLOCATE(ConstrStateData%FX)
!  IF ( ALLOCATED(ConstrStateData%FY) ) DEALLOCATE(ConstrStateData%FY)
!  IF ( ALLOCATED(ConstrStateData%FZ) ) DEALLOCATE(ConstrStateData%FZ)
! END SUBROUTINE MAP_DestroyConstrState
!
! SUBROUTINE MAP_PackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
!  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
!  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
!  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
!  TYPE(MAP_constraintstatetype),  INTENT(INOUT) :: InData
!  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
!  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
!  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
!    ! Local variables
!  INTEGER(IntKi)                 :: Re_BufSz
!  INTEGER(IntKi)                 :: Re_Xferred
!  INTEGER(IntKi)                 :: Re_CurrSz
!  INTEGER(IntKi)                 :: Db_BufSz
!  INTEGER(IntKi)                 :: Db_Xferred
!  INTEGER(IntKi)                 :: Db_CurrSz
!  INTEGER(IntKi)                 :: Int_BufSz
!  INTEGER(IntKi)                 :: Int_Xferred
!  INTEGER(IntKi)                 :: Int_CurrSz
!  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
!  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
! ! buffers to store meshes, if any
!  OnlySize = .FALSE.
!  IF ( PRESENT(SizeOnly) ) THEN
!    OnlySize = SizeOnly
!  ENDIF
!    !
!  ErrStat = ErrID_None
!  ErrMsg  = ""
!  Re_Xferred  = 1
!  Db_Xferred  = 1
!  Int_Xferred  = 1
!  Re_BufSz  = 0
!  Db_BufSz  = 0
!  Int_BufSz  = 0
!  Re_BufSz    = Re_BufSz    + SIZE( InData%X )  ! X 
!  Re_BufSz    = Re_BufSz    + SIZE( InData%Y )  ! Y 
!  Re_BufSz    = Re_BufSz    + SIZE( InData%Z )  ! Z 
!  Re_BufSz    = Re_BufSz    + SIZE( InData%FX )  ! FX 
!  Re_BufSz    = Re_BufSz    + SIZE( InData%FY )  ! FY 
!  Re_BufSz    = Re_BufSz    + SIZE( InData%FZ )  ! FZ 
!  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
!  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
!  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
!  IF ( ALLOCATED(InData%X) ) THEN
!    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%X))-1 ) =  PACK(InData%X ,.TRUE.)
!    Re_Xferred   = Re_Xferred   + SIZE(InData%X)
!  ENDIF
!  IF ( ALLOCATED(InData%Y) ) THEN
!    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Y))-1 ) =  PACK(InData%Y ,.TRUE.)
!    Re_Xferred   = Re_Xferred   + SIZE(InData%Y)
!  ENDIF
!  IF ( ALLOCATED(InData%Z) ) THEN
!    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Z))-1 ) =  PACK(InData%Z ,.TRUE.)
!    Re_Xferred   = Re_Xferred   + SIZE(InData%Z)
!  ENDIF
!  IF ( ALLOCATED(InData%FX) ) THEN
!    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FX))-1 ) =  PACK(InData%FX ,.TRUE.)
!    Re_Xferred   = Re_Xferred   + SIZE(InData%FX)
!  ENDIF
!  IF ( ALLOCATED(InData%FY) ) THEN
!    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FY))-1 ) =  PACK(InData%FY ,.TRUE.)
!    Re_Xferred   = Re_Xferred   + SIZE(InData%FY)
!  ENDIF
!  IF ( ALLOCATED(InData%FZ) ) THEN
!    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%FZ))-1 ) =  PACK(InData%FZ ,.TRUE.)
!    Re_Xferred   = Re_Xferred   + SIZE(InData%FZ)
!  ENDIF
! END SUBROUTINE MAP_PackConstrState
!
! SUBROUTINE MAP_UnpackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
!  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
!  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
!  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
!  TYPE(MAP_constraintstatetype), INTENT(INOUT) :: OutData
!  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
!  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
!    ! Local variables
!  INTEGER(IntKi)                 :: Re_BufSz
!  INTEGER(IntKi)                 :: Re_Xferred
!  INTEGER(IntKi)                 :: Re_CurrSz
!  INTEGER(IntKi)                 :: Db_BufSz
!  INTEGER(IntKi)                 :: Db_Xferred
!  INTEGER(IntKi)                 :: Db_CurrSz
!  INTEGER(IntKi)                 :: Int_BufSz
!  INTEGER(IntKi)                 :: Int_Xferred
!  INTEGER(IntKi)                 :: Int_CurrSz
!  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
!  LOGICAL, ALLOCATABLE           :: mask1(:)
!  LOGICAL, ALLOCATABLE           :: mask2(:,:)
!  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
!  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
!  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
! ! buffers to store meshes, if any
!    !
!  ErrStat = ErrID_None
!  ErrMsg  = ""
!  Re_Xferred  = 1
!  Db_Xferred  = 1
!  Int_Xferred  = 1
!  Re_BufSz  = 0
!  Db_BufSz  = 0
!  Int_BufSz  = 0
!  IF ( ALLOCATED(OutData%X) ) THEN
!  ALLOCATE(mask1(SIZE(OutData%X,1))); mask1 = .TRUE.
!    OutData%X = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%X))-1 ),mask1,OutData%X)
!  DEALLOCATE(mask1)
!    Re_Xferred   = Re_Xferred   + SIZE(OutData%X)
!  ENDIF
!  IF ( ALLOCATED(OutData%Y) ) THEN
!  ALLOCATE(mask1(SIZE(OutData%Y,1))); mask1 = .TRUE.
!    OutData%Y = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Y))-1 ),mask1,OutData%Y)
!  DEALLOCATE(mask1)
!    Re_Xferred   = Re_Xferred   + SIZE(OutData%Y)
!  ENDIF
!  IF ( ALLOCATED(OutData%Z) ) THEN
!  ALLOCATE(mask1(SIZE(OutData%Z,1))); mask1 = .TRUE.
!    OutData%Z = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Z))-1 ),mask1,OutData%Z)
!  DEALLOCATE(mask1)
!    Re_Xferred   = Re_Xferred   + SIZE(OutData%Z)
!  ENDIF
!  IF ( ALLOCATED(OutData%FX) ) THEN
!  ALLOCATE(mask1(SIZE(OutData%FX,1))); mask1 = .TRUE.
!    OutData%FX = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FX))-1 ),mask1,OutData%FX)
!  DEALLOCATE(mask1)
!    Re_Xferred   = Re_Xferred   + SIZE(OutData%FX)
!  ENDIF
!  IF ( ALLOCATED(OutData%FY) ) THEN
!  ALLOCATE(mask1(SIZE(OutData%FY,1))); mask1 = .TRUE.
!    OutData%FY = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FY))-1 ),mask1,OutData%FY)
!  DEALLOCATE(mask1)
!    Re_Xferred   = Re_Xferred   + SIZE(OutData%FY)
!  ENDIF
!  IF ( ALLOCATED(OutData%FZ) ) THEN
!  ALLOCATE(mask1(SIZE(OutData%FZ,1))); mask1 = .TRUE.
!    OutData%FZ = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%FZ))-1 ),mask1,OutData%FZ)
!  DEALLOCATE(mask1)
!    Re_Xferred   = Re_Xferred   + SIZE(OutData%FZ)
!  ENDIF
!  Re_Xferred   = Re_Xferred-1
!  Db_Xferred   = Db_Xferred-1
!  Int_Xferred  = Int_Xferred-1
! END SUBROUTINE MAP_UnpackConstrState
!
! SUBROUTINE MAP_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
!  TYPE(MAP_otherstatetype), INTENT(INOUT) :: SrcOtherStateData
!  TYPE(MAP_otherstatetype), INTENT(  OUT) :: DstOtherStateData
!  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
!  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
!  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
!! Local 
!  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
!! 
!  ErrStat = ErrID_None
!  ErrMsg  = ""
!  DstOtherStateData%Dummy = SrcOtherStateData%Dummy
! END SUBROUTINE MAP_CopyOtherState
!
! SUBROUTINE MAP_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
!  TYPE(MAP_otherstatetype), INTENT(INOUT) :: OtherStateData
!  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
!  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
!  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
!! 
!  ErrStat = ErrID_None
!  ErrMsg  = ""
! END SUBROUTINE MAP_DestroyOtherState
!
! SUBROUTINE MAP_PackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
!  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
!  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
!  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
!  TYPE(MAP_otherstatetype),  INTENT(INOUT) :: InData
!  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
!  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
!  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
!    ! Local variables
!  INTEGER(IntKi)                 :: Re_BufSz
!  INTEGER(IntKi)                 :: Re_Xferred
!  INTEGER(IntKi)                 :: Re_CurrSz
!  INTEGER(IntKi)                 :: Db_BufSz
!  INTEGER(IntKi)                 :: Db_Xferred
!  INTEGER(IntKi)                 :: Db_CurrSz
!  INTEGER(IntKi)                 :: Int_BufSz
!  INTEGER(IntKi)                 :: Int_Xferred
!  INTEGER(IntKi)                 :: Int_CurrSz
!  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
!  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
! ! buffers to store meshes, if any
!  OnlySize = .FALSE.
!  IF ( PRESENT(SizeOnly) ) THEN
!    OnlySize = SizeOnly
!  ENDIF
!    !
!  ErrStat = ErrID_None
!  ErrMsg  = ""
!  Re_Xferred  = 1
!  Db_Xferred  = 1
!  Int_Xferred  = 1
!  Re_BufSz  = 0
!  Db_BufSz  = 0
!  Int_BufSz  = 0
!  Re_BufSz   = Re_BufSz   + 1  ! Dummy
!  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
!  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
!  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
!  IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) =  (InData%Dummy )
!  Re_Xferred   = Re_Xferred   + 1
! END SUBROUTINE MAP_PackOtherState
!
! SUBROUTINE MAP_UnpackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
!  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
!  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
!  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
!  TYPE(MAP_otherstatetype), INTENT(INOUT) :: OutData
!  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
!  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
!    ! Local variables
!  INTEGER(IntKi)                 :: Re_BufSz
!  INTEGER(IntKi)                 :: Re_Xferred
!  INTEGER(IntKi)                 :: Re_CurrSz
!  INTEGER(IntKi)                 :: Db_BufSz
!  INTEGER(IntKi)                 :: Db_Xferred
!  INTEGER(IntKi)                 :: Db_CurrSz
!  INTEGER(IntKi)                 :: Int_BufSz
!  INTEGER(IntKi)                 :: Int_Xferred
!  INTEGER(IntKi)                 :: Int_CurrSz
!  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
!  LOGICAL, ALLOCATABLE           :: mask1(:)
!  LOGICAL, ALLOCATABLE           :: mask2(:,:)
!  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
!  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
!  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
! ! buffers to store meshes, if any
!    !
!  ErrStat = ErrID_None
!  ErrMsg  = ""
!  Re_Xferred  = 1
!  Db_Xferred  = 1
!  Int_Xferred  = 1
!  Re_BufSz  = 0
!  Db_BufSz  = 0
!  Int_BufSz  = 0
!  OutData%Dummy = ReKiBuf ( Re_Xferred )
!  Re_Xferred   = Re_Xferred   + 1
!  Re_Xferred   = Re_Xferred-1
!  Db_Xferred   = Db_Xferred-1
!  Int_Xferred  = Int_Xferred-1
! END SUBROUTINE MAP_UnpackOtherState
!
! SUBROUTINE MAP_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
!  TYPE(MAP_parametertype), INTENT(INOUT) :: SrcParamData
!  TYPE(MAP_parametertype), INTENT(  OUT) :: DstParamData
!  INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
!  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
!  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
!! Local 
!  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5,j,k
!! 
!  ErrStat = ErrID_None
!  ErrMsg  = ""
!  i1 = SIZE(SrcParamData%Diam,1)
!  IF (.NOT.ALLOCATED(DstParamData%Diam)) ALLOCATE(DstParamData%Diam(i1))
!  DstParamData%Diam = SrcParamData%Diam
!  i1 = SIZE(SrcParamData%MassDenInAir,1)
!  IF (.NOT.ALLOCATED(DstParamData%MassDenInAir)) ALLOCATE(DstParamData%MassDenInAir(i1))
!  DstParamData%MassDenInAir = SrcParamData%MassDenInAir
!  i1 = SIZE(SrcParamData%EA,1)
!  IF (.NOT.ALLOCATED(DstParamData%EA)) ALLOCATE(DstParamData%EA(i1))
!  DstParamData%EA = SrcParamData%EA
!  i1 = SIZE(SrcParamData%CB,1)
!  IF (.NOT.ALLOCATED(DstParamData%CB)) ALLOCATE(DstParamData%CB(i1))
!  DstParamData%CB = SrcParamData%CB
!  i1 = SIZE(SrcParamData%Lu,1)
!  IF (.NOT.ALLOCATED(DstParamData%Lu)) ALLOCATE(DstParamData%Lu(i1))
!  DstParamData%Lu = SrcParamData%Lu
!  DstParamData%PLOT_flag = SrcParamData%PLOT_flag
!  DstParamData%X_POS_flag = SrcParamData%X_POS_flag
!  DstParamData%Y_POS_flag = SrcParamData%Y_POS_flag
!  DstParamData%Z_POS_flag = SrcParamData%Z_POS_flag
!  DstParamData%X_FORCE_flag = SrcParamData%X_FORCE_flag
!  DstParamData%Y_FORCE_flag = SrcParamData%Y_FORCE_flag
!  DstParamData%Z_FORCE_flag = SrcParamData%Z_FORCE_flag
!  DstParamData%LINE_TENSION_flag = SrcParamData%LINE_TENSION_flag
!  DstParamData%OMIT_CONTACT_flag = SrcParamData%OMIT_CONTACT_flag
!  DstParamData%LAY_LENGTH_flag = SrcParamData%LAY_LENGTH_flag
! END SUBROUTINE MAP_CopyParam
!
! SUBROUTINE MAP_DestroyParam( ParamData, ErrStat, ErrMsg )
!  TYPE(MAP_parametertype), INTENT(INOUT) :: ParamData
!  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
!  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
!  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
!! 
!  ErrStat = ErrID_None
!  ErrMsg  = ""
!  IF ( ALLOCATED(ParamData%Diam) ) DEALLOCATE(ParamData%Diam)
!  IF ( ALLOCATED(ParamData%MassDenInAir) ) DEALLOCATE(ParamData%MassDenInAir)
!  IF ( ALLOCATED(ParamData%EA) ) DEALLOCATE(ParamData%EA)
!  IF ( ALLOCATED(ParamData%CB) ) DEALLOCATE(ParamData%CB)
!  IF ( ALLOCATED(ParamData%Lu) ) DEALLOCATE(ParamData%Lu)
! END SUBROUTINE MAP_DestroyParam
!
! SUBROUTINE MAP_PackParam( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
!  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
!  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
!  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
!  TYPE(MAP_parametertype),  INTENT(INOUT) :: InData
!  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
!  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
!  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
!    ! Local variables
!  INTEGER(IntKi)                 :: Re_BufSz
!  INTEGER(IntKi)                 :: Re_Xferred
!  INTEGER(IntKi)                 :: Re_CurrSz
!  INTEGER(IntKi)                 :: Db_BufSz
!  INTEGER(IntKi)                 :: Db_Xferred
!  INTEGER(IntKi)                 :: Db_CurrSz
!  INTEGER(IntKi)                 :: Int_BufSz
!  INTEGER(IntKi)                 :: Int_Xferred
!  INTEGER(IntKi)                 :: Int_CurrSz
!  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5     
!  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
! ! buffers to store meshes, if any
!  OnlySize = .FALSE.
!  IF ( PRESENT(SizeOnly) ) THEN
!    OnlySize = SizeOnly
!  ENDIF
!    !
!  ErrStat = ErrID_None
!  ErrMsg  = ""
!  Re_Xferred  = 1
!  Db_Xferred  = 1
!  Int_Xferred  = 1
!  Re_BufSz  = 0
!  Db_BufSz  = 0
!  Int_BufSz  = 0
!  Re_BufSz    = Re_BufSz    + SIZE( InData%Diam )  ! Diam 
!  Re_BufSz    = Re_BufSz    + SIZE( InData%MassDenInAir )  ! MassDenInAir 
!  Re_BufSz    = Re_BufSz    + SIZE( InData%EA )  ! EA 
!  Re_BufSz    = Re_BufSz    + SIZE( InData%CB )  ! CB 
!  Re_BufSz    = Re_BufSz    + SIZE( InData%Lu )  ! Lu 
!  IF ( Re_BufSz  .GT. 0 ) ALLOCATE( ReKiBuf(  Re_BufSz  ) )
!  IF ( Db_BufSz  .GT. 0 ) ALLOCATE( DbKiBuf(  Db_BufSz  ) )
!  IF ( Int_BufSz .GT. 0 ) ALLOCATE( IntKiBuf( Int_BufSz ) )
!  IF ( ALLOCATED(InData%Diam) ) THEN
!    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Diam))-1 ) =  PACK(InData%Diam ,.TRUE.)
!    Re_Xferred   = Re_Xferred   + SIZE(InData%Diam)
!  ENDIF
!  IF ( ALLOCATED(InData%MassDenInAir) ) THEN
!    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%MassDenInAir))-1 ) =  PACK(InData%MassDenInAir ,.TRUE.)
!    Re_Xferred   = Re_Xferred   + SIZE(InData%MassDenInAir)
!  ENDIF
!  IF ( ALLOCATED(InData%EA) ) THEN
!    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%EA))-1 ) =  PACK(InData%EA ,.TRUE.)
!    Re_Xferred   = Re_Xferred   + SIZE(InData%EA)
!  ENDIF
!  IF ( ALLOCATED(InData%CB) ) THEN
!    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CB))-1 ) =  PACK(InData%CB ,.TRUE.)
!    Re_Xferred   = Re_Xferred   + SIZE(InData%CB)
!  ENDIF
!  IF ( ALLOCATED(InData%Lu) ) THEN
!    IF ( .NOT. OnlySize ) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Lu))-1 ) =  PACK(InData%Lu ,.TRUE.)
!    Re_Xferred   = Re_Xferred   + SIZE(InData%Lu)
!  ENDIF
! END SUBROUTINE MAP_PackParam
!
! SUBROUTINE MAP_UnpackParam( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
!  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
!  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
!  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
!  TYPE(MAP_parametertype), INTENT(INOUT) :: OutData
!  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
!  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
!    ! Local variables
!  INTEGER(IntKi)                 :: Re_BufSz
!  INTEGER(IntKi)                 :: Re_Xferred
!  INTEGER(IntKi)                 :: Re_CurrSz
!  INTEGER(IntKi)                 :: Db_BufSz
!  INTEGER(IntKi)                 :: Db_Xferred
!  INTEGER(IntKi)                 :: Db_CurrSz
!  INTEGER(IntKi)                 :: Int_BufSz
!  INTEGER(IntKi)                 :: Int_Xferred
!  INTEGER(IntKi)                 :: Int_CurrSz
!  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5
!  LOGICAL, ALLOCATABLE           :: mask1(:)
!  LOGICAL, ALLOCATABLE           :: mask2(:,:)
!  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
!  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
!  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
! ! buffers to store meshes, if any
!    !
!  ErrStat = ErrID_None
!  ErrMsg  = ""
!  Re_Xferred  = 1
!  Db_Xferred  = 1
!  Int_Xferred  = 1
!  Re_BufSz  = 0
!  Db_BufSz  = 0
!  Int_BufSz  = 0
!  IF ( ALLOCATED(OutData%Diam) ) THEN
!  ALLOCATE(mask1(SIZE(OutData%Diam,1))); mask1 = .TRUE.
!    OutData%Diam = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Diam))-1 ),mask1,OutData%Diam)
!  DEALLOCATE(mask1)
!    Re_Xferred   = Re_Xferred   + SIZE(OutData%Diam)
!  ENDIF
!  IF ( ALLOCATED(OutData%MassDenInAir) ) THEN
!  ALLOCATE(mask1(SIZE(OutData%MassDenInAir,1))); mask1 = .TRUE.
!    OutData%MassDenInAir = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%MassDenInAir))-1 ),mask1,OutData%MassDenInAir)
!  DEALLOCATE(mask1)
!    Re_Xferred   = Re_Xferred   + SIZE(OutData%MassDenInAir)
!  ENDIF
!  IF ( ALLOCATED(OutData%EA) ) THEN
!  ALLOCATE(mask1(SIZE(OutData%EA,1))); mask1 = .TRUE.
!    OutData%EA = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%EA))-1 ),mask1,OutData%EA)
!  DEALLOCATE(mask1)
!    Re_Xferred   = Re_Xferred   + SIZE(OutData%EA)
!  ENDIF
!  IF ( ALLOCATED(OutData%CB) ) THEN
!  ALLOCATE(mask1(SIZE(OutData%CB,1))); mask1 = .TRUE.
!    OutData%CB = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CB))-1 ),mask1,OutData%CB)
!  DEALLOCATE(mask1)
!    Re_Xferred   = Re_Xferred   + SIZE(OutData%CB)
!  ENDIF
!  IF ( ALLOCATED(OutData%Lu) ) THEN
!  ALLOCATE(mask1(SIZE(OutData%Lu,1))); mask1 = .TRUE.
!    OutData%Lu = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Lu))-1 ),mask1,OutData%Lu)
!  DEALLOCATE(mask1)
!    Re_Xferred   = Re_Xferred   + SIZE(OutData%Lu)
!  ENDIF
!  Re_Xferred   = Re_Xferred-1
!  Db_Xferred   = Db_Xferred-1
!  Int_Xferred  = Int_Xferred-1
! END SUBROUTINE MAP_UnpackParam
!
! SUBROUTINE MAP_Pack( Re_RetAry, Db_RetAry, Int_RetAry, &
!                     InData, ParamData, ContStateData, DiscStateData, &
!                     ConstrStateData, OtherStateData, OutData, ErrStat, ErrMsg, &
!                     SizeOnly )
!  TYPE(MAP_InputType),           INTENT(INOUT) :: InData
!  TYPE(MAP_ParameterType),       INTENT(INOUT) :: ParamData
!  TYPE(MAP_ContinuousStateType), INTENT(INOUT) :: ContStateData
!  TYPE(MAP_DiscreteStateType),   INTENT(INOUT) :: DiscStateData
!  TYPE(MAP_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
!  TYPE(MAP_OtherStateType),      INTENT(INOUT) :: OtherStateData
!  TYPE(MAP_OutputType),          INTENT(INOUT) :: OutData
!  REAL(ReKi), ALLOCATABLE,      INTENT(  OUT) :: Re_RetAry(:)
!  REAL(DbKi), ALLOCATABLE,      INTENT(  OUT) :: Db_RetAry(:)
!  INTEGER(IntKi), ALLOCATABLE,  INTENT(  OUT) :: Int_RetAry(:)
!  INTEGER(IntKi),               INTENT(  OUT) :: ErrStat
!  CHARACTER(*),                 INTENT(  OUT) :: ErrMsg
!  LOGICAL, OPTIONAL,            INTENT(IN   ) :: SizeOnly
!    ! Local variables
!  REAL(ReKi), ALLOCATABLE                :: Re_Ary(:)
!  REAL(DbKi), ALLOCATABLE                :: Db_Ary(:)
!  INTEGER(IntKi), ALLOCATABLE            :: Int_Ary(:)
!  INTEGER(IntKi)                         :: Re_BufSz
!  INTEGER(IntKi)                         :: Re_Xferred
!  INTEGER(IntKi)                         :: Re_CurrSz
!  INTEGER(IntKi)                         :: Db_BufSz
!  INTEGER(IntKi)                         :: Db_Xferred
!  INTEGER(IntKi)                         :: Db_CurrSz
!  INTEGER(IntKi)                         :: Int_BufSz
!  INTEGER(IntKi)                         :: Int_Xferred
!  INTEGER(IntKi)                         :: Int_CurrSz
!  INTEGER(IntKi)                         :: ErrStat2
!  CHARACTER(Len(ErrMsg))                 :: ErrMsg2
!  LOGICAL                                :: OnlySize ! if present and true, do not pack, just allocate buffers
!    ! Executable statements
!  ErrStat = ErrID_None
!  ErrMsg  = ""
!  OnlySize = .FALSE.
!  IF ( PRESENT(SizeOnly) ) THEN
!    OnlySize = SizeOnly
!  ENDIF
!  Re_Xferred  = 1
!  Db_Xferred  = 1
!  Int_Xferred  = 1
!    ! Pack Input
!  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
!  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
!  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
!  CALL MAP_PackInput(Re_Ary,Db_Ary,Int_Ary,InData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
!  IF ( ALLOCATED( Re_Ary ) ) THEN
!    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
!    DEALLOCATE(Re_Ary)
!  ENDIF
!  IF ( ALLOCATED( Db_Ary ) ) THEN
!    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
!    DEALLOCATE(Db_Ary)
!  ENDIF
!  IF ( ALLOCATED( Int_Ary ) ) THEN
!    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
!    DEALLOCATE(Int_Ary)
!  ENDIF
!    ! Pack Param
!  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
!  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
!  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
!  CALL MAP_PackParam(Re_Ary,Db_Ary,Int_Ary,ParamData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
!  IF ( ALLOCATED( Re_Ary ) ) THEN
!    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
!    DEALLOCATE(Re_Ary)
!  ENDIF
!  IF ( ALLOCATED( Db_Ary ) ) THEN
!    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
!    DEALLOCATE(Db_Ary)
!  ENDIF
!  IF ( ALLOCATED( Int_Ary ) ) THEN
!    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
!    DEALLOCATE(Int_Ary)
!  ENDIF
!    ! Pack ContState
!  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
!  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
!  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
!  CALL MAP_PackContState(Re_Ary,Db_Ary,Int_Ary,ContStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
!  IF ( ALLOCATED( Re_Ary ) ) THEN
!    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
!    DEALLOCATE(Re_Ary)
!  ENDIF
!  IF ( ALLOCATED( Db_Ary ) ) THEN
!    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
!    DEALLOCATE(Db_Ary)
!  ENDIF
!  IF ( ALLOCATED( Int_Ary ) ) THEN
!    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
!    DEALLOCATE(Int_Ary)
!  ENDIF
!    ! Pack DiscState
!  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
!  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
!  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
!  CALL MAP_PackDiscState(Re_Ary,Db_Ary,Int_Ary,DiscStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
!  IF ( ALLOCATED( Re_Ary ) ) THEN
!    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
!    DEALLOCATE(Re_Ary)
!  ENDIF
!  IF ( ALLOCATED( Db_Ary ) ) THEN
!    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
!    DEALLOCATE(Db_Ary)
!  ENDIF
!  IF ( ALLOCATED( Int_Ary ) ) THEN
!    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
!    DEALLOCATE(Int_Ary)
!  ENDIF
!    ! Pack ConstrState
!  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
!  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
!  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
!  CALL MAP_PackConstrState(Re_Ary,Db_Ary,Int_Ary,ConstrStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
!  IF ( ALLOCATED( Re_Ary ) ) THEN
!    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
!    DEALLOCATE(Re_Ary)
!  ENDIF
!  IF ( ALLOCATED( Db_Ary ) ) THEN
!    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
!    DEALLOCATE(Db_Ary)
!  ENDIF
!  IF ( ALLOCATED( Int_Ary ) ) THEN
!    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
!    DEALLOCATE(Int_Ary)
!  ENDIF
!    ! Pack OtherState
!  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
!  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
!  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
!  CALL MAP_PackOtherState(Re_Ary,Db_Ary,Int_Ary,OtherStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
!  IF ( ALLOCATED( Re_Ary ) ) THEN
!    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
!    DEALLOCATE(Re_Ary)
!  ENDIF
!  IF ( ALLOCATED( Db_Ary ) ) THEN
!    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
!    DEALLOCATE(Db_Ary)
!  ENDIF
!  IF ( ALLOCATED( Int_Ary ) ) THEN
!    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
!    DEALLOCATE(Int_Ary)
!  ENDIF
!    ! Pack Output
!  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
!  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
!  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
!  CALL MAP_PackOutput(Re_Ary,Db_Ary,Int_Ary,OutData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
!  IF ( ALLOCATED( Re_Ary ) ) THEN
!    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
!    DEALLOCATE(Re_Ary)
!  ENDIF
!  IF ( ALLOCATED( Db_Ary ) ) THEN
!    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
!    DEALLOCATE(Db_Ary)
!  ENDIF
!  IF ( ALLOCATED( Int_Ary ) ) THEN
!    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
!    DEALLOCATE(Int_Ary)
!  ENDIF
!  Re_Xferred  = Re_Xferred - 1
!  Db_Xferred  = Db_Xferred - 1
!  Int_Xferred  = Int_Xferred - 1
!  IF ( ALLOCATED( Re_RetAry ) ) DEALLOCATE( Re_RetAry ) ;
!  IF ( Re_Xferred .GT. 0) ALLOCATE( Re_RetAry( Re_Xferred ) ) ;
!  IF ( ALLOCATED( Db_RetAry ) ) DEALLOCATE( Db_RetAry ) ;
!  IF ( Db_Xferred .GT. 0) ALLOCATE( Db_RetAry( Db_Xferred ) ) ;
!  IF ( ALLOCATED( Int_RetAry ) ) DEALLOCATE( Int_RetAry ) ;
!  IF ( Int_Xferred .GT. 0) ALLOCATE( Int_RetAry( Int_Xferred ) ) ;
!  Re_Xferred  = 1
!  Db_Xferred  = 1
!  Int_Xferred  = 1
!    ! Pack Input
!  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
!  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
!  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
!  CALL MAP_PackInput(Re_Ary,Db_Ary,Int_Ary,InData,ErrStat2,ErrMsg2)
!  IF ( ALLOCATED( Re_Ary ) ) THEN
!    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
!    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
!    DEALLOCATE(Re_Ary)
!  ENDIF
!  IF ( ALLOCATED( Db_Ary ) ) THEN
!    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
!    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
!    DEALLOCATE(Db_Ary)
!  ENDIF
!  IF ( ALLOCATED( Int_Ary ) ) THEN
!    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
!    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
!    DEALLOCATE(Int_Ary)
!  ENDIF
!    ! Pack Param
!  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
!  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
!  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
!  CALL MAP_PackParam(Re_Ary,Db_Ary,Int_Ary,ParamData,ErrStat2,ErrMsg2)
!  IF ( ALLOCATED( Re_Ary ) ) THEN
!    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
!    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
!    DEALLOCATE(Re_Ary)
!  ENDIF
!  IF ( ALLOCATED( Db_Ary ) ) THEN
!    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
!    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
!    DEALLOCATE(Db_Ary)
!  ENDIF
!  IF ( ALLOCATED( Int_Ary ) ) THEN
!    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
!    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
!    DEALLOCATE(Int_Ary)
!  ENDIF
!    ! Pack ContState
!  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
!  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
!  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
!  CALL MAP_PackContState(Re_Ary,Db_Ary,Int_Ary,ContStateData,ErrStat2,ErrMsg2)
!  IF ( ALLOCATED( Re_Ary ) ) THEN
!    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
!    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
!    DEALLOCATE(Re_Ary)
!  ENDIF
!  IF ( ALLOCATED( Db_Ary ) ) THEN
!    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
!    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
!    DEALLOCATE(Db_Ary)
!  ENDIF
!  IF ( ALLOCATED( Int_Ary ) ) THEN
!    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
!    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
!    DEALLOCATE(Int_Ary)
!  ENDIF
!    ! Pack DiscState
!  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
!  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
!  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
!  CALL MAP_PackDiscState(Re_Ary,Db_Ary,Int_Ary,DiscStateData,ErrStat2,ErrMsg2)
!  IF ( ALLOCATED( Re_Ary ) ) THEN
!    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
!    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
!    DEALLOCATE(Re_Ary)
!  ENDIF
!  IF ( ALLOCATED( Db_Ary ) ) THEN
!    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
!    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
!    DEALLOCATE(Db_Ary)
!  ENDIF
!  IF ( ALLOCATED( Int_Ary ) ) THEN
!    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
!    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
!    DEALLOCATE(Int_Ary)
!  ENDIF
!    ! Pack ConstrState
!  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
!  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
!  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
!  CALL MAP_PackConstrState(Re_Ary,Db_Ary,Int_Ary,ConstrStateData,ErrStat2,ErrMsg2)
!  IF ( ALLOCATED( Re_Ary ) ) THEN
!    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
!    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
!    DEALLOCATE(Re_Ary)
!  ENDIF
!  IF ( ALLOCATED( Db_Ary ) ) THEN
!    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
!    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
!    DEALLOCATE(Db_Ary)
!  ENDIF
!  IF ( ALLOCATED( Int_Ary ) ) THEN
!    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
!    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
!    DEALLOCATE(Int_Ary)
!  ENDIF
!    ! Pack OtherState
!  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
!  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
!  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
!  CALL MAP_PackOtherState(Re_Ary,Db_Ary,Int_Ary,OtherStateData,ErrStat2,ErrMsg2)
!  IF ( ALLOCATED( Re_Ary ) ) THEN
!    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
!    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
!    DEALLOCATE(Re_Ary)
!  ENDIF
!  IF ( ALLOCATED( Db_Ary ) ) THEN
!    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
!    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
!    DEALLOCATE(Db_Ary)
!  ENDIF
!  IF ( ALLOCATED( Int_Ary ) ) THEN
!    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
!    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
!    DEALLOCATE(Int_Ary)
!  ENDIF
!    ! Pack Output
!  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
!  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
!  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
!  CALL MAP_PackOutput(Re_Ary,Db_Ary,Int_Ary,OutData,ErrStat2,ErrMsg2)
!  IF ( ALLOCATED( Re_Ary ) ) THEN
!    IF ( .NOT. OnlySize ) Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)=Re_Ary
!    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
!    DEALLOCATE(Re_Ary)
!  ENDIF
!  IF ( ALLOCATED( Db_Ary ) ) THEN
!    IF ( .NOT. OnlySize ) Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)=Db_Ary
!    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
!    DEALLOCATE(Db_Ary)
!  ENDIF
!  IF ( ALLOCATED( Int_Ary ) ) THEN
!    IF ( .NOT. OnlySize ) Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)=Int_Ary
!    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
!    DEALLOCATE(Int_Ary)
!  ENDIF
!  Re_Xferred   = Re_Xferred - 1
!  Db_Xferred   = Db_Xferred - 1
!  Int_Xferred  = Int_Xferred - 1
! END SUBROUTINE MAP_Pack
!
! SUBROUTINE MAP_Unpack( Re_RetAry, Db_RetAry, Int_RetAry, &
!                     InData, ParamData, ContStateData, DiscStateData, &
!                     ConstrStateData, OtherStateData, OutData, ErrStat, ErrMsg )
!  TYPE(MAP_InputType),           INTENT(INOUT) :: InData
!  TYPE(MAP_ParameterType),       INTENT(INOUT) :: ParamData
!  TYPE(MAP_ContinuousStateType), INTENT(INOUT) :: ContStateData
!  TYPE(MAP_DiscreteStateType),   INTENT(INOUT) :: DiscStateData
!  TYPE(MAP_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
!  TYPE(MAP_OtherStateType),      INTENT(INOUT) :: OtherStateData
!  TYPE(MAP_OutputType),          INTENT(INOUT) :: OutData
!  REAL(ReKi), ALLOCATABLE,      INTENT(IN   ) :: Re_RetAry(:)
!  REAL(DbKi), ALLOCATABLE,      INTENT(IN   ) :: Db_RetAry(:)
!  INTEGER(IntKi), ALLOCATABLE,   INTENT(IN   ) :: Int_RetAry(:)
!  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
!  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
!    ! Local variables
!  REAL(ReKi), ALLOCATABLE                :: Re_Ary(:)
!  REAL(DbKi), ALLOCATABLE                :: Db_Ary(:)
!  INTEGER(IntKi), ALLOCATABLE            :: Int_Ary(:)
!  INTEGER(IntKi)                         :: Re_BufSz
!  INTEGER(IntKi)                         :: Re_Xferred
!  INTEGER(IntKi)                         :: Re_CurrSz
!  INTEGER(IntKi)                         :: Db_BufSz
!  INTEGER(IntKi)                         :: Db_Xferred
!  INTEGER(IntKi)                         :: Db_CurrSz
!  INTEGER(IntKi)                         :: Int_BufSz
!  INTEGER(IntKi)                         :: Int_Xferred
!  INTEGER(IntKi)                         :: Int_CurrSz
!  INTEGER(IntKi)                         :: ErrStat2
!  CHARACTER(Len(ErrMsg))                 :: ErrMsg2
!  ErrStat = ErrID_None
!  ErrMsg  = ""
!  Re_Xferred  = 1
!  Db_Xferred  = 1
!  Int_Xferred  = 1
!    ! Unpack Input
!  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
!  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
!  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
!  CALL MAP_PackInput(Re_Ary,Db_Ary,Int_Ary,InData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
!  IF ( ALLOCATED( Re_Ary ) ) THEN
!    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
!    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
!  ENDIF
!  IF ( ALLOCATED( Db_Ary ) ) THEN
!    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
!    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
!  ENDIF
!  IF ( ALLOCATED( Int_Ary ) ) THEN
!    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
!    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
!  ENDIF
!  CALL MAP_UnpackInput(Re_Ary,Db_Ary,Int_Ary,InData,ErrStat2,ErrMsg2)
!  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
!  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
!  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
!    ! Unpack Param
!  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
!  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
!  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
!  CALL MAP_PackParam(Re_Ary,Db_Ary,Int_Ary,ParamData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
!  IF ( ALLOCATED( Re_Ary ) ) THEN
!    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
!    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
!  ENDIF
!  IF ( ALLOCATED( Db_Ary ) ) THEN
!    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
!    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
!  ENDIF
!  IF ( ALLOCATED( Int_Ary ) ) THEN
!    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
!    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
!  ENDIF
!  CALL MAP_UnpackParam(Re_Ary,Db_Ary,Int_Ary,ParamData,ErrStat2,ErrMsg2)
!  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
!  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
!  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
!    ! Unpack ContState
!  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
!  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
!  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
!  CALL MAP_PackContState(Re_Ary,Db_Ary,Int_Ary,ContStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
!  IF ( ALLOCATED( Re_Ary ) ) THEN
!    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
!    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
!  ENDIF
!  IF ( ALLOCATED( Db_Ary ) ) THEN
!    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
!    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
!  ENDIF
!  IF ( ALLOCATED( Int_Ary ) ) THEN
!    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
!    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
!  ENDIF
!  CALL MAP_UnpackContState(Re_Ary,Db_Ary,Int_Ary,ContStateData,ErrStat2,ErrMsg2)
!  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
!  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
!  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
!    ! Unpack DiscState
!  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
!  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
!  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
!  CALL MAP_PackDiscState(Re_Ary,Db_Ary,Int_Ary,DiscStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
!  IF ( ALLOCATED( Re_Ary ) ) THEN
!    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
!    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
!  ENDIF
!  IF ( ALLOCATED( Db_Ary ) ) THEN
!    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
!    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
!  ENDIF
!  IF ( ALLOCATED( Int_Ary ) ) THEN
!    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
!    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
!  ENDIF
!  CALL MAP_UnpackDiscState(Re_Ary,Db_Ary,Int_Ary,DiscStateData,ErrStat2,ErrMsg2)
!  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
!  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
!  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
!    ! Unpack ConstrState
!  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
!  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
!  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
!  CALL MAP_PackConstrState(Re_Ary,Db_Ary,Int_Ary,ConstrStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
!  IF ( ALLOCATED( Re_Ary ) ) THEN
!    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
!    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
!  ENDIF
!  IF ( ALLOCATED( Db_Ary ) ) THEN
!    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
!    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
!  ENDIF
!  IF ( ALLOCATED( Int_Ary ) ) THEN
!    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
!    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
!  ENDIF
!  CALL MAP_UnpackConstrState(Re_Ary,Db_Ary,Int_Ary,ConstrStateData,ErrStat2,ErrMsg2)
!  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
!  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
!  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
!    ! Unpack OtherState
!  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
!  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
!  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
!  CALL MAP_PackOtherState(Re_Ary,Db_Ary,Int_Ary,OtherStateData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
!  IF ( ALLOCATED( Re_Ary ) ) THEN
!    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
!    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
!  ENDIF
!  IF ( ALLOCATED( Db_Ary ) ) THEN
!    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
!    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
!  ENDIF
!  IF ( ALLOCATED( Int_Ary ) ) THEN
!    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
!    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
!  ENDIF
!  CALL MAP_UnpackOtherState(Re_Ary,Db_Ary,Int_Ary,OtherStateData,ErrStat2,ErrMsg2)
!  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
!  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
!  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
!    ! Unpack Output
!  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
!  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
!  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
!  CALL MAP_PackOutput(Re_Ary,Db_Ary,Int_Ary,OutData,ErrStat2,ErrMsg2,SizeOnly=.TRUE.)
!  IF ( ALLOCATED( Re_Ary ) ) THEN
!    Re_Ary = Re_RetAry(Re_Xferred:Re_Xferred+SIZE(Re_Ary)-1)
!    Re_Xferred = Re_Xferred + SIZE( Re_Ary )
!  ENDIF
!  IF ( ALLOCATED( Db_Ary ) ) THEN
!    DB_Ary = Db_RetAry(Db_Xferred:Db_Xferred+SIZE(Db_Ary)-1)
!    Db_Xferred = Db_Xferred + SIZE( Db_Ary )
!  ENDIF
!  IF ( ALLOCATED( Int_Ary ) ) THEN
!    Int_Ary = Int_RetAry(Int_Xferred:Int_Xferred+SIZE(Int_Ary)-1)
!    Int_Xferred = Int_Xferred + SIZE( Int_Ary )
!  ENDIF
!  CALL MAP_UnpackOutput(Re_Ary,Db_Ary,Int_Ary,OutData,ErrStat2,ErrMsg2)
!  IF ( ALLOCATED( Re_Ary ) )  DEALLOCATE(Re_Ary)
!  IF ( ALLOCATED( Db_Ary ) )  DEALLOCATE(Db_Ary)
!  IF ( ALLOCATED( Int_Ary ) )  DEALLOCATE(Int_Ary)
!  Re_Xferred   = Re_Xferred-1
!  Db_Xferred   = Db_Xferred-1
!  Int_Xferred  = Int_Xferred-1
! END SUBROUTINE MAP_Unpack
!
!
! SUBROUTINE MAP_Input_ExtrapInterp(u, t, u_out, t_out, ErrStat, ErrMsg )
!!
!! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
!! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!!
!!  expressions below based on either
!!
!!  f(t) = a
!!  f(t) = a + b * t, or
!!  f(t) = a + b * t + c * t**2
!!
!!  where a, b and c are determined as the solution to
!!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!!
!!..................................................................................................................................
!
! TYPE(MAP_inputtype), INTENT(IN   )  :: u(:)      ! Inputs at t1 > t2 > t3
! REAL(DbKi),         INTENT(IN   )  :: t(:)      ! Times associated with the inputs
! TYPE(MAP_inputtype), INTENT(  OUT)  :: u_out     ! Inputs at t1 > t2 > t3
! REAL(DbKi),         INTENT(IN   )  :: t_out     ! time to be extrap/interp'd to
! INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
! CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
!   ! local variables
! INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
! REAL(ReKi)                                 :: a0       ! temporary for extrapolaton/interpolation
! REAL(ReKi)                                 :: b0       ! temporary for extrapolation/interpolation
! REAL(ReKi)                                 :: c0       ! temporary for extrapolation/interpolation
! REAL(ReKi),ALLOCATABLE,DIMENSION(:)        :: a1       ! temporary for extrapolaton/interpolation
! REAL(ReKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
! REAL(ReKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
! REAL(ReKi),ALLOCATABLE,DIMENSION(:,:)      :: a2       ! temporary for extrapolaton/interpolation
! REAL(ReKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
! REAL(ReKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
! REAL(ReKi),ALLOCATABLE,DIMENSION(:,:,:)    :: a3       ! temporary for extrapolaton/interpolation
! REAL(ReKi),ALLOCATABLE,DIMENSION(:,:,:)    :: b3       ! temporary for extrapolation/interpolation
! REAL(ReKi),ALLOCATABLE,DIMENSION(:,:,:)    :: c3       ! temporary for extrapolation/interpolation
! REAL(ReKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: a4       ! temporary for extrapolaton/interpolation
! REAL(ReKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: b4       ! temporary for extrapolation/interpolation
! REAL(ReKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: c4       ! temporary for extrapolation/interpolation
! REAL(ReKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: a5       ! temporary for extrapolaton/interpolation
! REAL(ReKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: b5       ! temporary for extrapolation/interpolation
! REAL(ReKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: c5       ! temporary for extrapolation/interpolation
! INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
! INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
! INTEGER                                    :: i21    ! dim1 level 2 counter variable for arrays of ddts
! INTEGER                                    :: i31    ! dim1 level 3 counter variable for arrays of ddts
! INTEGER                                    :: i41    ! dim1 level 4 counter variable for arrays of ddts
! INTEGER                                    :: i51    ! dim1 level 5 counter variable for arrays of ddts
! INTEGER                                    :: i61    ! dim1 level 6 counter variable for arrays of ddts
! INTEGER                                    :: i71    ! dim1 level 7 counter variable for arrays of ddts
! INTEGER                                    :: i81    ! dim1 level 8 counter variable for arrays of ddts
! INTEGER                                    :: i91    ! dim1 level 9 counter variable for arrays of ddts
! INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
! INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
! INTEGER                                    :: i22    ! dim2 level 2 counter variable for arrays of ddts
! INTEGER                                    :: i32    ! dim2 level 3 counter variable for arrays of ddts
! INTEGER                                    :: i42    ! dim2 level 4 counter variable for arrays of ddts
! INTEGER                                    :: i52    ! dim2 level 5 counter variable for arrays of ddts
! INTEGER                                    :: i62    ! dim2 level 6 counter variable for arrays of ddts
! INTEGER                                    :: i72    ! dim2 level 7 counter variable for arrays of ddts
! INTEGER                                    :: i82    ! dim2 level 8 counter variable for arrays of ddts
! INTEGER                                    :: i92    ! dim2 level 9 counter variable for arrays of ddts
! INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
! INTEGER                                    :: i13    ! dim3 level 1 counter variable for arrays of ddts
! INTEGER                                    :: i23    ! dim3 level 2 counter variable for arrays of ddts
! INTEGER                                    :: i33    ! dim3 level 3 counter variable for arrays of ddts
! INTEGER                                    :: i43    ! dim3 level 4 counter variable for arrays of ddts
! INTEGER                                    :: i53    ! dim3 level 5 counter variable for arrays of ddts
! INTEGER                                    :: i63    ! dim3 level 6 counter variable for arrays of ddts
! INTEGER                                    :: i73    ! dim3 level 7 counter variable for arrays of ddts
! INTEGER                                    :: i83    ! dim3 level 8 counter variable for arrays of ddts
! INTEGER                                    :: i93    ! dim3 level 9 counter variable for arrays of ddts
! INTEGER                                    :: i04    ! dim4 level 0 counter variable for arrays of ddts
! INTEGER                                    :: i14    ! dim4 level 1 counter variable for arrays of ddts
! INTEGER                                    :: i24    ! dim4 level 2 counter variable for arrays of ddts
! INTEGER                                    :: i34    ! dim4 level 3 counter variable for arrays of ddts
! INTEGER                                    :: i44    ! dim4 level 4 counter variable for arrays of ddts
! INTEGER                                    :: i54    ! dim4 level 5 counter variable for arrays of ddts
! INTEGER                                    :: i64    ! dim4 level 6 counter variable for arrays of ddts
! INTEGER                                    :: i74    ! dim4 level 7 counter variable for arrays of ddts
! INTEGER                                    :: i84    ! dim4 level 8 counter variable for arrays of ddts
! INTEGER                                    :: i94    ! dim4 level 9 counter variable for arrays of ddts
! INTEGER                                    :: i05    ! dim5 level 0 counter variable for arrays of ddts
! INTEGER                                    :: i15    ! dim5 level 1 counter variable for arrays of ddts
! INTEGER                                    :: i25    ! dim5 level 2 counter variable for arrays of ddts
! INTEGER                                    :: i35    ! dim5 level 3 counter variable for arrays of ddts
! INTEGER                                    :: i45    ! dim5 level 4 counter variable for arrays of ddts
! INTEGER                                    :: i55    ! dim5 level 5 counter variable for arrays of ddts
! INTEGER                                    :: i65    ! dim5 level 6 counter variable for arrays of ddts
! INTEGER                                    :: i75    ! dim5 level 7 counter variable for arrays of ddts
! INTEGER                                    :: i85    ! dim5 level 8 counter variable for arrays of ddts
! INTEGER                                    :: i95    ! dim5 level 9 counter variable for arrays of ddts
!    ! Initialize ErrStat
!    ! Initialize ErrStat
! ErrStat = ErrID_None
! ErrMsg  = ""
! if ( size(t) .ne. size(u)) then
!    ErrStat = ErrID_Fatal
!    ErrMsg = ' Error in MAP_Input_ExtrapInterp: size(t) must equal size(u) '
!    RETURN
! endif
!
! if (size(u) .gt. 3) then
!    ErrStat = ErrID_Fatal
!    ErrMsg  = ' Error in MAP_Input_ExtrapInterp: size(u) must be less than 4 '
!    RETURN
! endif
! order = SIZE(u) - 1
! IF ( order .eq. 0 ) THEN
!  u_out%X = u(1)%X
!  u_out%Y = u(1)%Y
!  u_out%Z = u(1)%Z
! ELSE IF ( order .eq. 1 ) THEN
!  IF ( EqualRealNos( t(1), t(2) ) ) THEN
!    ErrStat = ErrID_Fatal
!    ErrMsg  = ' Error in MAP_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
!    RETURN
!  END IF
!  ALLOCATE(a1(SIZE(u_out%X,1)))
!  ALLOCATE(b1(SIZE(u_out%X,1)))
!  ALLOCATE(c1(SIZE(u_out%X,1)))
!  a1 = -((t(2)*u(1)%X - t(1)*u(2)%X)/(t(1) - t(2)))
!  b1 = -((-u(1)%X + u(2)%X)/(t(1) - t(2)))
!  u_out%X = a1 + b1 * t_out
!  DEALLOCATE(a1)
!  DEALLOCATE(b1)
!  DEALLOCATE(c1)
!  ALLOCATE(a1(SIZE(u_out%Y,1)))
!  ALLOCATE(b1(SIZE(u_out%Y,1)))
!  ALLOCATE(c1(SIZE(u_out%Y,1)))
!  a1 = -((t(2)*u(1)%Y - t(1)*u(2)%Y)/(t(1) - t(2)))
!  b1 = -((-u(1)%Y + u(2)%Y)/(t(1) - t(2)))
!  u_out%Y = a1 + b1 * t_out
!  DEALLOCATE(a1)
!  DEALLOCATE(b1)
!  DEALLOCATE(c1)
!  ALLOCATE(a1(SIZE(u_out%Z,1)))
!  ALLOCATE(b1(SIZE(u_out%Z,1)))
!  ALLOCATE(c1(SIZE(u_out%Z,1)))
!  a1 = -((t(2)*u(1)%Z - t(1)*u(2)%Z)/(t(1) - t(2)))
!  b1 = -((-u(1)%Z + u(2)%Z)/(t(1) - t(2)))
!  u_out%Z = a1 + b1 * t_out
!  DEALLOCATE(a1)
!  DEALLOCATE(b1)
!  DEALLOCATE(c1)
! ELSE IF ( order .eq. 2 ) THEN
!  IF ( EqualRealNos( t(1), t(2) ) ) THEN
!    ErrStat = ErrID_Fatal
!    ErrMsg  = ' Error in MAP_Input_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
!    RETURN
!  END IF
!  IF ( EqualRealNos( t(2), t(3) ) ) THEN
!    ErrStat = ErrID_Fatal
!    ErrMsg  = ' Error in MAP_Input_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
!    RETURN
!  END IF
!  IF ( EqualRealNos( t(1), t(3) ) ) THEN
!    ErrStat = ErrID_Fatal
!    ErrMsg  = ' Error in MAP_Input_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
!    RETURN
!  END IF
!  ALLOCATE(a1(SIZE(u_out%X,1)))
!  ALLOCATE(b1(SIZE(u_out%X,1)))
!  ALLOCATE(c1(SIZE(u_out%X,1)))
!  a1 = (t(1)*t(3)*(-t(1) + t(3))*u(2)%X &
!      + t(2)**2*(t(3)*u(1)%X - t(1)*u(3)%X)        &
!      + t(2)*(-(t(3)**2*u(1)%X) + t(1)**2*u(3)%X))                        &
!      / ((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))
!  b1 = (t(3)**2*(u(1)%X - u(2)%X) &
!      + t(1)**2*(u(2)%X - u(3)%X) + t(2)**2*(-u(1)%X &
!      + u(3)%X))/((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))                  
!  c1 = (t(3)*(-u(1)%X + u(2)%X) &
!      + t(2)*(u(1)%X - u(3)%X) &
!      + t(1)*(-u(2)%X + u(3)%X))  &
!      /((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))
!  u_out%X = a1 + b1 * t_out + c1 * t_out**2
!  DEALLOCATE(a1)
!  DEALLOCATE(b1)
!  DEALLOCATE(c1)
!  ALLOCATE(a1(SIZE(u_out%Y,1)))
!  ALLOCATE(b1(SIZE(u_out%Y,1)))
!  ALLOCATE(c1(SIZE(u_out%Y,1)))
!  a1 = (t(1)*t(3)*(-t(1) + t(3))*u(2)%Y &
!      + t(2)**2*(t(3)*u(1)%Y - t(1)*u(3)%Y)        &
!      + t(2)*(-(t(3)**2*u(1)%Y) + t(1)**2*u(3)%Y))                        &
!      / ((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))
!  b1 = (t(3)**2*(u(1)%Y - u(2)%Y) &
!      + t(1)**2*(u(2)%Y - u(3)%Y) + t(2)**2*(-u(1)%Y &
!      + u(3)%Y))/((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))                  
!  c1 = (t(3)*(-u(1)%Y + u(2)%Y) &
!      + t(2)*(u(1)%Y - u(3)%Y) &
!      + t(1)*(-u(2)%Y + u(3)%Y))  &
!      /((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))
!  u_out%Y = a1 + b1 * t_out + c1 * t_out**2
!  DEALLOCATE(a1)
!  DEALLOCATE(b1)
!  DEALLOCATE(c1)
!  ALLOCATE(a1(SIZE(u_out%Z,1)))
!  ALLOCATE(b1(SIZE(u_out%Z,1)))
!  ALLOCATE(c1(SIZE(u_out%Z,1)))
!  a1 = (t(1)*t(3)*(-t(1) + t(3))*u(2)%Z &
!      + t(2)**2*(t(3)*u(1)%Z - t(1)*u(3)%Z)        &
!      + t(2)*(-(t(3)**2*u(1)%Z) + t(1)**2*u(3)%Z))                        &
!      / ((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))
!  b1 = (t(3)**2*(u(1)%Z - u(2)%Z) &
!      + t(1)**2*(u(2)%Z - u(3)%Z) + t(2)**2*(-u(1)%Z &
!      + u(3)%Z))/((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))                  
!  c1 = (t(3)*(-u(1)%Z + u(2)%Z) &
!      + t(2)*(u(1)%Z - u(3)%Z) &
!      + t(1)*(-u(2)%Z + u(3)%Z))  &
!      /((t(1) - t(2))*(t(1) - t(3))*(t(2) - t(3)))
!  u_out%Z = a1 + b1 * t_out + c1 * t_out**2
!  DEALLOCATE(a1)
!  DEALLOCATE(b1)
!  DEALLOCATE(c1)
! ELSE 
!   ErrStat = ErrID_Fatal
!   ErrMsg = ' order must be less than 3 in MAP_Input_ExtrapInterp '
!   RETURN
! ENDIF 
! END SUBROUTINE MAP_Input_ExtrapInterp
!
!
! SUBROUTINE MAP_Output_ExtrapInterp(u, t, u_out, t_out, ErrStat, ErrMsg )
!!
!! This subroutine calculates a extrapolated (or interpolated) input u_out at time t_out, from previous/future time
!! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!!
!!  expressions below based on either
!!
!!  f(t) = a
!!  f(t) = a + b * t, or
!!  f(t) = a + b * t + c * t**2
!!
!!  where a, b and c are determined as the solution to
!!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!!
!!..................................................................................................................................
!
! TYPE(MAP_outputtype), INTENT(IN   )  :: u(:)      ! Inputs at t1 > t2 > t3
! REAL(DbKi),         INTENT(IN   )  :: t(:)      ! Times associated with the inputs
! TYPE(MAP_outputtype), INTENT(  OUT)  :: u_out     ! Inputs at t1 > t2 > t3
! REAL(DbKi),         INTENT(IN   )  :: t_out     ! time to be extrap/interp'd to
! INTEGER(IntKi),     INTENT(  OUT)  :: ErrStat   ! Error status of the operation
! CHARACTER(*),       INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
!   ! local variables
! INTEGER(IntKi)                 :: order    ! order of polynomial fit (max 2)
! REAL(ReKi)                                 :: a0       ! temporary for extrapolaton/interpolation
! REAL(ReKi)                                 :: b0       ! temporary for extrapolation/interpolation
! REAL(ReKi)                                 :: c0       ! temporary for extrapolation/interpolation
! REAL(ReKi),ALLOCATABLE,DIMENSION(:)        :: a1       ! temporary for extrapolaton/interpolation
! REAL(ReKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
! REAL(ReKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
! REAL(ReKi),ALLOCATABLE,DIMENSION(:,:)      :: a2       ! temporary for extrapolaton/interpolation
! REAL(ReKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
! REAL(ReKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
! REAL(ReKi),ALLOCATABLE,DIMENSION(:,:,:)    :: a3       ! temporary for extrapolaton/interpolation
! REAL(ReKi),ALLOCATABLE,DIMENSION(:,:,:)    :: b3       ! temporary for extrapolation/interpolation
! REAL(ReKi),ALLOCATABLE,DIMENSION(:,:,:)    :: c3       ! temporary for extrapolation/interpolation
! REAL(ReKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: a4       ! temporary for extrapolaton/interpolation
! REAL(ReKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: b4       ! temporary for extrapolation/interpolation
! REAL(ReKi),ALLOCATABLE,DIMENSION(:,:,:,:)  :: c4       ! temporary for extrapolation/interpolation
! REAL(ReKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: a5       ! temporary for extrapolaton/interpolation
! REAL(ReKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: b5       ! temporary for extrapolation/interpolation
! REAL(ReKi),ALLOCATABLE,DIMENSION(:,:,:,:,:):: c5       ! temporary for extrapolation/interpolation
! INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
! INTEGER                                    :: i11    ! dim1 level 1 counter variable for arrays of ddts
! INTEGER                                    :: i21    ! dim1 level 2 counter variable for arrays of ddts
! INTEGER                                    :: i31    ! dim1 level 3 counter variable for arrays of ddts
! INTEGER                                    :: i41    ! dim1 level 4 counter variable for arrays of ddts
! INTEGER                                    :: i51    ! dim1 level 5 counter variable for arrays of ddts
! INTEGER                                    :: i61    ! dim1 level 6 counter variable for arrays of ddts
! INTEGER                                    :: i71    ! dim1 level 7 counter variable for arrays of ddts
! INTEGER                                    :: i81    ! dim1 level 8 counter variable for arrays of ddts
! INTEGER                                    :: i91    ! dim1 level 9 counter variable for arrays of ddts
! INTEGER                                    :: i02    ! dim2 level 0 counter variable for arrays of ddts
! INTEGER                                    :: i12    ! dim2 level 1 counter variable for arrays of ddts
! INTEGER                                    :: i22    ! dim2 level 2 counter variable for arrays of ddts
! INTEGER                                    :: i32    ! dim2 level 3 counter variable for arrays of ddts
! INTEGER                                    :: i42    ! dim2 level 4 counter variable for arrays of ddts
! INTEGER                                    :: i52    ! dim2 level 5 counter variable for arrays of ddts
! INTEGER                                    :: i62    ! dim2 level 6 counter variable for arrays of ddts
! INTEGER                                    :: i72    ! dim2 level 7 counter variable for arrays of ddts
! INTEGER                                    :: i82    ! dim2 level 8 counter variable for arrays of ddts
! INTEGER                                    :: i92    ! dim2 level 9 counter variable for arrays of ddts
! INTEGER                                    :: i03    ! dim3 level 0 counter variable for arrays of ddts
! INTEGER                                    :: i13    ! dim3 level 1 counter variable for arrays of ddts
! INTEGER                                    :: i23    ! dim3 level 2 counter variable for arrays of ddts
! INTEGER                                    :: i33    ! dim3 level 3 counter variable for arrays of ddts
! INTEGER                                    :: i43    ! dim3 level 4 counter variable for arrays of ddts
! INTEGER                                    :: i53    ! dim3 level 5 counter variable for arrays of ddts
! INTEGER                                    :: i63    ! dim3 level 6 counter variable for arrays of ddts
! INTEGER                                    :: i73    ! dim3 level 7 counter variable for arrays of ddts
! INTEGER                                    :: i83    ! dim3 level 8 counter variable for arrays of ddts
! INTEGER                                    :: i93    ! dim3 level 9 counter variable for arrays of ddts
! INTEGER                                    :: i04    ! dim4 level 0 counter variable for arrays of ddts
! INTEGER                                    :: i14    ! dim4 level 1 counter variable for arrays of ddts
! INTEGER                                    :: i24    ! dim4 level 2 counter variable for arrays of ddts
! INTEGER                                    :: i34    ! dim4 level 3 counter variable for arrays of ddts
! INTEGER                                    :: i44    ! dim4 level 4 counter variable for arrays of ddts
! INTEGER                                    :: i54    ! dim4 level 5 counter variable for arrays of ddts
! INTEGER                                    :: i64    ! dim4 level 6 counter variable for arrays of ddts
! INTEGER                                    :: i74    ! dim4 level 7 counter variable for arrays of ddts
! INTEGER                                    :: i84    ! dim4 level 8 counter variable for arrays of ddts
! INTEGER                                    :: i94    ! dim4 level 9 counter variable for arrays of ddts
! INTEGER                                    :: i05    ! dim5 level 0 counter variable for arrays of ddts
! INTEGER                                    :: i15    ! dim5 level 1 counter variable for arrays of ddts
! INTEGER                                    :: i25    ! dim5 level 2 counter variable for arrays of ddts
! INTEGER                                    :: i35    ! dim5 level 3 counter variable for arrays of ddts
! INTEGER                                    :: i45    ! dim5 level 4 counter variable for arrays of ddts
! INTEGER                                    :: i55    ! dim5 level 5 counter variable for arrays of ddts
! INTEGER                                    :: i65    ! dim5 level 6 counter variable for arrays of ddts
! INTEGER                                    :: i75    ! dim5 level 7 counter variable for arrays of ddts
! INTEGER                                    :: i85    ! dim5 level 8 counter variable for arrays of ddts
! INTEGER                                    :: i95    ! dim5 level 9 counter variable for arrays of ddts
!    ! Initialize ErrStat
!    ! Initialize ErrStat
! ErrStat = ErrID_None
! ErrMsg  = ""
! if ( size(t) .ne. size(u)) then
!    ErrStat = ErrID_Fatal
!    ErrMsg = ' Error in MAP_Output_ExtrapInterp: size(t) must equal size(u) '
!    RETURN
! endif
!
! if (size(u) .gt. 3) then
!    ErrStat = ErrID_Fatal
!    ErrMsg  = ' Error in MAP_Output_ExtrapInterp: size(u) must be less than 4 '
!    RETURN
! endif
! order = SIZE(u) - 1
! IF ( order .eq. 0 ) THEN
! ELSE IF ( order .eq. 1 ) THEN
!  IF ( EqualRealNos( t(1), t(2) ) ) THEN
!    ErrStat = ErrID_Fatal
!    ErrMsg  = ' Error in MAP_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
!    RETURN
!  END IF
! ELSE IF ( order .eq. 2 ) THEN
!  IF ( EqualRealNos( t(1), t(2) ) ) THEN
!    ErrStat = ErrID_Fatal
!    ErrMsg  = ' Error in MAP_Output_ExtrapInterp: t(1) must not equal t(2) to avoid a division-by-zero error.'
!    RETURN
!  END IF
!  IF ( EqualRealNos( t(2), t(3) ) ) THEN
!    ErrStat = ErrID_Fatal
!    ErrMsg  = ' Error in MAP_Output_ExtrapInterp: t(2) must not equal t(3) to avoid a division-by-zero error.'
!    RETURN
!  END IF
!  IF ( EqualRealNos( t(1), t(3) ) ) THEN
!    ErrStat = ErrID_Fatal
!    ErrMsg  = ' Error in MAP_Output_ExtrapInterp: t(1) must not equal t(3) to avoid a division-by-zero error.'
!    RETURN
!  END IF
! ELSE 
!   ErrStat = ErrID_Fatal
!   ErrMsg = ' order must be less than 3 in MAP_Output_ExtrapInterp '
!   RETURN
! ENDIF 
! END SUBROUTINE MAP_Output_ExtrapInterp

END MODULE MAP_Types
!ENDOFREGISTRYGENERATEDFILE
